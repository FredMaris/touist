# Notes by MaÃ«l:
#
# Did new message appear when I updated parser.mly?
# =================================================
# To check if some new states should be present in parser.messages
# after an update of the grammar (parser.mly), I explained the way to do
# in HOWTODEBUG.md.
#
# How to write the error messages
# ===============================
# We can use the tokens $0, $1, $2... that will be replaced by the i-th last
# token that has been read. $0 will typically show the token that has been read
# right before an error occurred.
# Example:
# The dot is where we are stopped. Here, the parser didn't expect to read "end".
# NOTE: I modified the [element checkpoint i] to display the failing token in $0,
#       and the following tokens are accessible via $1, $2...
# Here is what the $i tokens contain:
#
#     begin formula atleast  (   1   , [a] . end  formula
#                               $3  $2  $1    $0
# NOTE: simple quotes ' ' will be added; dont write $1 but rather $1 directly.
#
# =========================================================================
touist_smt: ATLEAST VAR COMMA VAR XOR 
##
## Ends in an error in state: 462.
##
## generalized_connectors(formula_smt) -> ATLEAST int COMMA set_prop . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## ATLEAST int COMMA set_prop 
##
touist_smt: ATMOST VAR COMMA VAR XOR 
##
## Ends in an error in state: 457.
##
## generalized_connectors(formula_smt) -> ATMOST int COMMA set_prop . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## ATMOST int COMMA set_prop 
##
touist_smt: EXACT VAR COMMA VAR XOR 
##
## Ends in an error in state: 439.
##
## generalized_connectors(formula_smt) -> EXACT int COMMA set_prop . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## EXACT int COMMA set_prop 
##
touist_simple: ATLEAST VAR COMMA VAR XOR 
##
## Ends in an error in state: 354.
##
## generalized_connectors(formula_simple) -> ATLEAST int COMMA set_prop . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## ATLEAST int COMMA set_prop 
##
touist_simple: ATMOST VAR COMMA VAR XOR 
##
## Ends in an error in state: 349.
##
## generalized_connectors(formula_simple) -> ATMOST int COMMA set_prop . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## ATMOST int COMMA set_prop 
##
touist_simple: EXACT VAR COMMA VAR XOR 
##
## Ends in an error in state: 325.
##
## generalized_connectors(formula_simple) -> EXACT int COMMA set_prop . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## EXACT int COMMA set_prop 
##

Ill-formed $4 statement. At this point, either finish the
$4 statement by a ')' or continue the set of propositions started by:
    $1
Instead, the following statement were read:
    $0

touist_smt: ATLEAST VAR COMMA XOR 
##
## Ends in an error in state: 461.
##
## generalized_connectors(formula_smt) -> ATLEAST int COMMA . set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## ATLEAST int COMMA 
##
touist_smt: ATMOST VAR COMMA XOR 
##
## Ends in an error in state: 456.
##
## generalized_connectors(formula_smt) -> ATMOST int COMMA . set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## ATMOST int COMMA 
##
touist_smt: EXACT VAR COMMA XOR 
##
## Ends in an error in state: 438.
##
## generalized_connectors(formula_smt) -> EXACT int COMMA . set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## EXACT int COMMA 
##
touist_simple: ATLEAST VAR COMMA XOR 
##
## Ends in an error in state: 353.
##
## generalized_connectors(formula_simple) -> ATLEAST int COMMA . set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## ATLEAST int COMMA 
##
touist_simple: ATMOST VAR COMMA XOR 
##
## Ends in an error in state: 348.
##
## generalized_connectors(formula_simple) -> ATMOST int COMMA . set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## ATMOST int COMMA 
##
touist_simple: EXACT VAR COMMA XOR 
##
## Ends in an error in state: 324.
##
## generalized_connectors(formula_simple) -> EXACT int COMMA . set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## EXACT int COMMA 
##

Ill-formed $3 statement. At this point, a set of propositions
was expected.
Instead, the following statement were read:
    $0

touist_smt: ATLEAST VAR XOR 
##
## Ends in an error in state: 460.
##
## generalized_connectors(formula_smt) -> ATLEAST int . COMMA set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## num_operations_others(int) -> int . MOD int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . ADD int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB MUL MOD DIV COMMA ADD ]
##
## The known suffix of the stack is as follows:
## ATLEAST int 
##
touist_smt: ATMOST VAR XOR 
##
## Ends in an error in state: 455.
##
## generalized_connectors(formula_smt) -> ATMOST int . COMMA set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## num_operations_others(int) -> int . MOD int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . ADD int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB MUL MOD DIV COMMA ADD ]
##
## The known suffix of the stack is as follows:
## ATMOST int 
##
touist_smt: EXACT VAR XOR 
##
## Ends in an error in state: 437.
##
## generalized_connectors(formula_smt) -> EXACT int . COMMA set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## num_operations_others(int) -> int . MOD int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . ADD int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB MUL MOD DIV COMMA ADD ]
##
## The known suffix of the stack is as follows:
## EXACT int 
##
touist_simple: ATLEAST VAR XOR 
##
## Ends in an error in state: 352.
##
## generalized_connectors(formula_simple) -> ATLEAST int . COMMA set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## num_operations_others(int) -> int . MOD int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . ADD int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB MUL MOD DIV COMMA ADD ]
##
## The known suffix of the stack is as follows:
## ATLEAST int 
##
touist_simple: ATMOST VAR XOR 
##
## Ends in an error in state: 347.
##
## generalized_connectors(formula_simple) -> ATMOST int . COMMA set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## num_operations_others(int) -> int . MOD int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . ADD int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB MUL MOD DIV COMMA ADD ]
##
## The known suffix of the stack is as follows:
## ATMOST int 
##
touist_simple: EXACT VAR XOR 
##
## Ends in an error in state: 323.
##
## generalized_connectors(formula_simple) -> EXACT int . COMMA set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## num_operations_others(int) -> int . MOD int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . ADD int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB MUL MOD DIV COMMA ADD ]
##
## The known suffix of the stack is as follows:
## EXACT int 
##

Ill-formed $2 statement. At this point, either finish the integer
expression with ',' or continue the integer expression started with:
    $1
Instead, the following statement were read:
    $0

touist_smt: ATLEAST XOR 
##
## Ends in an error in state: 459.
##
## generalized_connectors(formula_smt) -> ATLEAST . int COMMA set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## ATLEAST 
##
touist_smt: ATMOST XOR 
##
## Ends in an error in state: 454.
##
## generalized_connectors(formula_smt) -> ATMOST . int COMMA set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## ATMOST 
##
touist_smt: EXACT XOR 
##
## Ends in an error in state: 436.
##
## generalized_connectors(formula_smt) -> EXACT . int COMMA set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## EXACT 
##
touist_simple: ATLEAST XOR 
##
## Ends in an error in state: 351.
##
## generalized_connectors(formula_simple) -> ATLEAST . int COMMA set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## ATLEAST 
##
touist_simple: ATMOST XOR 
##
## Ends in an error in state: 346.
##
## generalized_connectors(formula_simple) -> ATMOST . int COMMA set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## ATMOST 
##
touist_simple: EXACT XOR 
##
## Ends in an error in state: 322.
##
## generalized_connectors(formula_simple) -> EXACT . int COMMA set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## EXACT 
##

Ill-formed $1 statement. At this point, an integer is expected.
Instead, the following statement were read:
    $0

touist_smt: CARD DIFF XOR 
##
## Ends in an error in state: 246.
##
## set_operation(set_float) -> DIFF . set_float COMMA set_float RPAREN [ WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## set_operation(set_int) -> DIFF . set_int COMMA set_int RPAREN [ WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## set_operation(set_prop) -> DIFF . set_prop COMMA set_prop RPAREN [ WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
##
## The known suffix of the stack is as follows:
## DIFF 
##
touist_smt: CARD UNION XOR 
##
## Ends in an error in state: 13.
##
## set_operation(set_float) -> UNION . set_float COMMA set_float RPAREN [ WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## set_operation(set_int) -> UNION . set_int COMMA set_int RPAREN [ WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## set_operation(set_prop) -> UNION . set_prop COMMA set_prop RPAREN [ WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
##
## The known suffix of the stack is as follows:
## UNION 
##

Ill-formed $1 statement. At this point, a set is expected.
Instead, the following statement were read:
    $0

touist_simple: BIGAND VAR IN LBRACK INT RBRACK COLON VAR WHEN 
##
## Ends in an error in state: 363.
##
## connectors(formula_simple) -> formula_simple . AND formula_simple [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_simple) -> formula_simple . OR formula_simple [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_simple) -> formula_simple . XOR formula_simple [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_simple) -> formula_simple . IMPLIES formula_simple [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_simple) -> formula_simple . EQUIV formula_simple [ XOR OR IMPLIES EQUIV END AND ]
## generalized_connectors(formula_simple) -> BIGAND comma_list(var) IN comma_list(any_set) option(when_cond) COLON formula_simple . END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## BIGAND comma_list(var) IN comma_list(any_set) option(when_cond) COLON formula_simple 
##
touist_smt: BIGOR VAR IN LBRACK INT RBRACK COLON VAR VARTUPLE 
##
## Ends in an error in state: 501.
##
## connectors(formula_smt) -> formula_smt . AND formula_smt [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_smt) -> formula_smt . OR formula_smt [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_smt) -> formula_smt . XOR formula_smt [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_smt) -> formula_smt . IMPLIES formula_smt [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_smt) -> formula_smt . EQUIV formula_smt [ XOR OR IMPLIES EQUIV END AND ]
## generalized_connectors(formula_smt) -> BIGOR comma_list(var) IN comma_list(any_set) option(when_cond) COLON formula_smt . END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## BIGOR comma_list(var) IN comma_list(any_set) option(when_cond) COLON formula_smt 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 254, spurious reduction of production prop -> var 
## In state 464, spurious reduction of production formula(formula_smt) -> prop 
## In state 475, spurious reduction of production formula_smt -> formula(formula_smt) 
##
touist_simple: BIGOR VAR IN LBRACK INT RBRACK COLON VAR WHEN 
##
## Ends in an error in state: 380.
##
## connectors(formula_simple) -> formula_simple . AND formula_simple [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_simple) -> formula_simple . OR formula_simple [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_simple) -> formula_simple . XOR formula_simple [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_simple) -> formula_simple . IMPLIES formula_simple [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_simple) -> formula_simple . EQUIV formula_simple [ XOR OR IMPLIES EQUIV END AND ]
## generalized_connectors(formula_simple) -> BIGOR comma_list(var) IN comma_list(any_set) option(when_cond) COLON formula_simple . END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## BIGOR comma_list(var) IN comma_list(any_set) option(when_cond) COLON formula_simple 
##
touist_smt: BIGAND VAR IN LBRACK TERM RBRACK COLON VAR VARTUPLE 
##
## Ends in an error in state: 472.
##
## connectors(formula_smt) -> formula_smt . AND formula_smt [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_smt) -> formula_smt . OR formula_smt [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_smt) -> formula_smt . XOR formula_smt [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_smt) -> formula_smt . IMPLIES formula_smt [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_smt) -> formula_smt . EQUIV formula_smt [ XOR OR IMPLIES EQUIV END AND ]
## generalized_connectors(formula_smt) -> BIGAND comma_list(var) IN comma_list(any_set) option(when_cond) COLON formula_smt . END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## BIGAND comma_list(var) IN comma_list(any_set) option(when_cond) COLON formula_smt 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 254, spurious reduction of production prop -> var 
## In state 464, spurious reduction of production formula(formula_smt) -> prop 
## In state 475, spurious reduction of production formula_smt -> formula(formula_smt) 
##

Ill-formed $7 body. At this point, expecting either 'end' or
a continuation of the formula that was started with
    $1
using one of the following formula connectors
    and, or, xor, =>, <=>.
Instead, the following statement were read:
    $0
Important: in $7, you cannot write 'a b'. It must be written 'a and b'.
Explanation: $7 expects a formula, but 'a b' is a list of formulas and
is only allowed outside $7

touist_smt: BIGAND VAR IN LBRACK INT RBRACK COLON XOR 
##
## Ends in an error in state: 453.
##
## generalized_connectors(formula_smt) -> BIGAND comma_list(var) IN comma_list(any_set) option(when_cond) COLON . formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## BIGAND comma_list(var) IN comma_list(any_set) option(when_cond) COLON 
##
touist_simple: BIGAND VAR IN LBRACK INT RBRACK COLON XOR 
##
## Ends in an error in state: 345.
##
## generalized_connectors(formula_simple) -> BIGAND comma_list(var) IN comma_list(any_set) option(when_cond) COLON . formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## BIGAND comma_list(var) IN comma_list(any_set) option(when_cond) COLON 
##
touist_smt: BIGOR VAR IN LBRACK INT RBRACK COLON XOR 
##
## Ends in an error in state: 447.
##
## generalized_connectors(formula_smt) -> BIGOR comma_list(var) IN comma_list(any_set) option(when_cond) COLON . formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## BIGOR comma_list(var) IN comma_list(any_set) option(when_cond) COLON 
##
touist_simple: BIGOR VAR IN LBRACK INT RBRACK COLON XOR 
##
## Ends in an error in state: 339.
##
## generalized_connectors(formula_simple) -> BIGOR comma_list(var) IN comma_list(any_set) option(when_cond) COLON . formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## BIGOR comma_list(var) IN comma_list(any_set) option(when_cond) COLON 
##

Ill-formed $6 body. At this point, a formula is expected.
Instead, the following statement were read:
    $0

touist_smt: BIGAND VAR IN LBRACK INT RBRACK XOR 
##
## Ends in an error in state: 451.
##
## generalized_connectors(formula_smt) -> BIGAND comma_list(var) IN comma_list(any_set) . option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## BIGAND comma_list(var) IN comma_list(any_set) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 377, spurious reduction of production comma_list(any_set) -> any_set 
##
touist_smt: BIGOR VAR IN LBRACK INT RBRACK XOR 
##
## Ends in an error in state: 445.
##
## generalized_connectors(formula_smt) -> BIGOR comma_list(var) IN comma_list(any_set) . option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## BIGOR comma_list(var) IN comma_list(any_set) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 377, spurious reduction of production comma_list(any_set) -> any_set 
##
touist_simple: BIGAND VAR IN LBRACK INT RBRACK XOR 
##
## Ends in an error in state: 343.
##
## generalized_connectors(formula_simple) -> BIGAND comma_list(var) IN comma_list(any_set) . option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## BIGAND comma_list(var) IN comma_list(any_set) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 377, spurious reduction of production comma_list(any_set) -> any_set 
##
touist_simple: BIGOR VAR IN LBRACK INT RBRACK XOR 
##
## Ends in an error in state: 334.
##
## generalized_connectors(formula_simple) -> BIGOR comma_list(var) IN comma_list(any_set) . option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## BIGOR comma_list(var) IN comma_list(any_set) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 377, spurious reduction of production comma_list(any_set) -> any_set 
##

Ill-formed $4 statement. At this point, expecting either ':' or 'when' or
a continuation of the comma-separated list of sets you started with:
    $1
Instead, the following statement were read:
    $0

touist_smt: BIGAND VAR IN XOR 
##
## Ends in an error in state: 450.
##
## generalized_connectors(formula_smt) -> BIGAND comma_list(var) IN . comma_list(any_set) option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## BIGAND comma_list(var) IN 
##
touist_smt: BIGOR VAR IN XOR 
##
## Ends in an error in state: 444.
##
## generalized_connectors(formula_smt) -> BIGOR comma_list(var) IN . comma_list(any_set) option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## BIGOR comma_list(var) IN 
##
touist_simple: BIGAND VAR IN XOR 
##
## Ends in an error in state: 342.
##
## generalized_connectors(formula_simple) -> BIGAND comma_list(var) IN . comma_list(any_set) option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## BIGAND comma_list(var) IN 
##
touist_simple: BIGOR VAR IN XOR 
##
## Ends in an error in state: 333.
##
## generalized_connectors(formula_simple) -> BIGOR comma_list(var) IN . comma_list(any_set) option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## BIGOR comma_list(var) IN 
##

Ill-formed $3. At this point, a comma-separated list of sets is expected.
Instead, the following statement were read:
    $0

touist_smt: BIGAND VAR XOR 
##
## Ends in an error in state: 449.
##
## generalized_connectors(formula_smt) -> BIGAND comma_list(var) . IN comma_list(any_set) option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## BIGAND comma_list(var) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production comma_list(var) -> var 
##
touist_smt: BIGOR VAR XOR 
##
## Ends in an error in state: 443.
##
## generalized_connectors(formula_smt) -> BIGOR comma_list(var) . IN comma_list(any_set) option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## BIGOR comma_list(var) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production comma_list(var) -> var 
##
touist_simple: BIGAND VAR XOR 
##
## Ends in an error in state: 341.
##
## generalized_connectors(formula_simple) -> BIGAND comma_list(var) . IN comma_list(any_set) option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## BIGAND comma_list(var) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production comma_list(var) -> var 
##
touist_simple: BIGOR VAR XOR 
##
## Ends in an error in state: 332.
##
## generalized_connectors(formula_simple) -> BIGOR comma_list(var) . IN comma_list(any_set) option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## BIGOR comma_list(var) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production comma_list(var) -> var 
##

Ill-formed $2. At this point, either finish with 'in' or continue the list of
variables that was started with:
    $1
Instead, the following statement were read:
    $0

touist_smt: BIGAND XOR 
##
## Ends in an error in state: 448.
##
## generalized_connectors(formula_smt) -> BIGAND . comma_list(var) IN comma_list(any_set) option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## BIGAND 
##
touist_simple: BIGAND XOR 
##
## Ends in an error in state: 340.
##
## generalized_connectors(formula_simple) -> BIGAND . comma_list(var) IN comma_list(any_set) option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## BIGAND 
##
touist_simple: BIGOR XOR 
##
## Ends in an error in state: 328.
##
## generalized_connectors(formula_simple) -> BIGOR . comma_list(var) IN comma_list(any_set) option(when_cond) COLON formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## BIGOR 
##
touist_smt: BIGOR XOR 
##
## Ends in an error in state: 442.
##
## generalized_connectors(formula_smt) -> BIGOR . comma_list(var) IN comma_list(any_set) option(when_cond) COLON formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## BIGOR 
##

Ill-formed $1. At this point, a comma-separated list of variables is expected.
Instead, the following statement were read:
    $0

touist_smt: CARD DIFF LBRACK INT RBRACK COMMA VAR XOR 
##
## Ends in an error in state: 183.
##
## set_operation(set_int) -> DIFF set_int COMMA set_int . RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## DIFF set_int COMMA set_int 
##
touist_smt: CARD INTER LBRACK INT RBRACK COMMA VAR XOR 
##
## Ends in an error in state: 194.
##
## set_operation(set_int) -> INTER set_int COMMA set_int . RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## INTER set_int COMMA set_int 
##
touist_smt: CARD UNION LBRACK INT RBRACK COMMA VAR XOR 
##
## Ends in an error in state: 198.
##
## set_operation(set_int) -> UNION set_int COMMA set_int . RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## UNION set_int COMMA set_int 
##
touist_simple: IF SUBSET LBRACK INT RBRACK COMMA VAR XOR 
##
## Ends in an error in state: 284.
##
## subset_statement -> SUBSET set_int COMMA set_int . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## SUBSET set_int COMMA set_int 
##

Ill-formed $4. Either finish it with ')' or continue the set of integers
that was started with:
    $1
Instead, the following statement were read:
    $0

touist_smt: CARD INTER VAR COMMA VAR XOR 
##
## Ends in an error in state: 163.
##
## set_operation(set_float) -> INTER set_float COMMA set_float . RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## INTER set_float COMMA set_float 
##
touist_smt: CARD DIFF VAR COMMA VAR XOR 
##
## Ends in an error in state: 144.
##
## set_operation(set_float) -> DIFF set_float COMMA set_float . RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## DIFF set_float COMMA set_float 
##
touist_smt: CARD UNION VAR COMMA VAR XOR 
##
## Ends in an error in state: 167.
##
## set_operation(set_float) -> UNION set_float COMMA set_float . RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## UNION set_float COMMA set_float 
##
touist_simple: IF SUBSET VAR COMMA VAR XOR 
##
## Ends in an error in state: 288.
##
## subset_statement -> SUBSET set_float COMMA set_float . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## SUBSET set_float COMMA set_float 
##

Ill-formed $4. Either finish it with ')' or continue the set of floats
that was started with:
    $1
Instead, the following statement were read:
    $0

touist_smt: CARD DIFF LBRACK TERM RBRACK COMMA VAR XOR 
##
## Ends in an error in state: 213.
##
## set_operation(set_prop) -> DIFF set_prop COMMA set_prop . RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## DIFF set_prop COMMA set_prop 
##
touist_smt: CARD INTER LBRACK TERM RBRACK COMMA VAR XOR 
##
## Ends in an error in state: 224.
##
## set_operation(set_prop) -> INTER set_prop COMMA set_prop . RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## INTER set_prop COMMA set_prop 
##
touist_smt: CARD UNION LBRACK VAR RBRACK COMMA VAR XOR 
##
## Ends in an error in state: 228.
##
## set_operation(set_prop) -> UNION set_prop COMMA set_prop . RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## UNION set_prop COMMA set_prop 
##
touist_simple: IF SUBSET LBRACK VAR RBRACK COMMA VAR XOR 
##
## Ends in an error in state: 280.
##
## subset_statement -> SUBSET set_prop COMMA set_prop . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## SUBSET set_prop COMMA set_prop 
##

Ill-formed $4. Either finish it with ')' or continue the set of propositions
that was started with:
    $1
Instead, the following statement were read:
    $0

touist_smt: CARD DIFF LBRACK INT RBRACK COMMA XOR 
##
## Ends in an error in state: 182.
##
## set_operation(set_int) -> DIFF set_int COMMA . set_int RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## DIFF set_int COMMA 
##
touist_smt: CARD INTER LBRACK INT RBRACK COMMA XOR 
##
## Ends in an error in state: 193.
##
## set_operation(set_int) -> INTER set_int COMMA . set_int RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## INTER set_int COMMA 
##
touist_smt: CARD UNION LBRACK INT RBRACK COMMA XOR 
##
## Ends in an error in state: 197.
##
## set_operation(set_int) -> UNION set_int COMMA . set_int RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## UNION set_int COMMA 
##
touist_simple: IF SUBSET LBRACK INT RBRACK COMMA XOR 
##
## Ends in an error in state: 283.
##
## subset_statement -> SUBSET set_int COMMA . set_int RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## SUBSET set_int COMMA 
##

Ill-formed $3. A set of integers is expected after $1; the first parameter
of $3 has been recognized as a set of integer:
    $2
Instead, the following statement were read:
    $0

touist_smt: CARD DIFF VAR COMMA XOR 
##
## Ends in an error in state: 143.
##
## set_operation(set_float) -> DIFF set_float COMMA . set_float RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## DIFF set_float COMMA 
##
touist_simple: IF SUBSET VAR COMMA XOR 
##
## Ends in an error in state: 287.
##
## subset_statement -> SUBSET set_float COMMA . set_float RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## SUBSET set_float COMMA 
##
touist_smt: CARD INTER VAR COMMA XOR 
##
## Ends in an error in state: 162.
##
## set_operation(set_float) -> INTER set_float COMMA . set_float RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## INTER set_float COMMA 
##
touist_smt: CARD UNION VAR COMMA XOR 
##
## Ends in an error in state: 166.
##
## set_operation(set_float) -> UNION set_float COMMA . set_float RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## UNION set_float COMMA 
##

Ill-formed $3. A set of floats is expected after $1; the first parameter
of $3 has been recognized as a set of floats:
    $2
Instead, the following statement were read:
    $0

touist_smt: CARD DIFF LBRACK TERM RBRACK COMMA XOR 
##
## Ends in an error in state: 212.
##
## set_operation(set_prop) -> DIFF set_prop COMMA . set_prop RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## DIFF set_prop COMMA 
##
touist_smt: CARD INTER LBRACK TERM RBRACK COMMA XOR 
##
## Ends in an error in state: 223.
##
## set_operation(set_prop) -> INTER set_prop COMMA . set_prop RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## INTER set_prop COMMA 
##
touist_smt: CARD UNION LBRACK VAR RBRACK COMMA XOR 
##
## Ends in an error in state: 227.
##
## set_operation(set_prop) -> UNION set_prop COMMA . set_prop RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## UNION set_prop COMMA 
##
touist_simple: IF SUBSET LBRACK VAR RBRACK COMMA XOR 
##
## Ends in an error in state: 279.
##
## subset_statement -> SUBSET set_prop COMMA . set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## SUBSET set_prop COMMA 
##

Ill-formed $3. A set of propositions is expected after $1; the first parameter
of $3 has been recognized as a set of propositions:
    $2
Instead, the following statement were read:
    $0

touist_smt: CARD DIFF LBRACK INT RBRACK XOR 
##
## Ends in an error in state: 181.
##
## set_operation(set_int) -> DIFF set_int . COMMA set_int RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## DIFF set_int 
##
touist_smt: CARD INTER LBRACK INT RBRACK XOR 
##
## Ends in an error in state: 192.
##
## set_operation(set_int) -> INTER set_int . COMMA set_int RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## INTER set_int 
##
touist_smt: CARD UNION LBRACK INT RBRACK XOR 
##
## Ends in an error in state: 196.
##
## set_operation(set_int) -> UNION set_int . COMMA set_int RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## UNION set_int 
##
touist_simple: IF SUBSET LBRACK INT RBRACK XOR 
##
## Ends in an error in state: 282.
##
## subset_statement -> SUBSET set_int . COMMA set_int RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## SUBSET set_int 
##

Ill-formed $2. Either finish with ',' the set of integers started with:
    $1
Instead, the following statement were read:
    $0

touist_smt: CARD DIFF VAR XOR 
##
## Ends in an error in state: 142.
##
## set_operation(set_float) -> DIFF set_float . COMMA set_float RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## DIFF set_float 
##
touist_smt: CARD INTER VAR XOR 
##
## Ends in an error in state: 161.
##
## set_operation(set_float) -> INTER set_float . COMMA set_float RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## INTER set_float 
##
touist_smt: CARD UNION VAR XOR 
##
## Ends in an error in state: 165.
##
## set_operation(set_float) -> UNION set_float . COMMA set_float RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## UNION set_float 
##
touist_simple: IF SUBSET VAR XOR 
##
## Ends in an error in state: 286.
##
## subset_statement -> SUBSET set_float . COMMA set_float RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## SUBSET set_float 
##

Ill-formed $2. Either finish with ',' the set of floats started with:
    $1
Instead, the following statement were read:
    $0

touist_smt: CARD DIFF LBRACK TERM RBRACK XOR 
##
## Ends in an error in state: 211.
##
## set_operation(set_prop) -> DIFF set_prop . COMMA set_prop RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## DIFF set_prop 
##
touist_smt: CARD INTER LBRACK TERM RBRACK XOR 
##
## Ends in an error in state: 222.
##
## set_operation(set_prop) -> INTER set_prop . COMMA set_prop RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## INTER set_prop 
##
touist_smt: CARD UNION LBRACK VAR RBRACK XOR 
##
## Ends in an error in state: 226.
##
## set_operation(set_prop) -> UNION set_prop . COMMA set_prop RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## UNION set_prop 
##
touist_simple: IF SUBSET LBRACK VAR RBRACK XOR 
##
## Ends in an error in state: 278.
##
## subset_statement -> SUBSET set_prop . COMMA set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## SUBSET set_prop 
##

Ill-formed $2. Either finish with ',' the set of propositions started with:
    $1
Instead, the following statement were read:
    $0

touist_simple: VAR AFFECT IF VAR THEN XOR 
##
## Ends in an error in state: 400.
##
## if_statement(bool) -> IF bool THEN . bool ELSE bool END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF ELSE CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## if_statement(float) -> IF bool THEN . float ELSE float END [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF ELSE DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## if_statement(int) -> IF bool THEN . int ELSE int END [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF ELSE DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## if_statement(set_float) -> IF bool THEN . set_float ELSE set_float END [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## if_statement(set_int) -> IF bool THEN . set_int ELSE set_int END [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## if_statement(set_prop) -> IF bool THEN . set_prop ELSE set_prop END [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN 
##

Ill-formed $3. After 'then', either one of the following is expected:
- a set of integer, float or propositions,
- an integer, a float or a proposition.
Instead, the following statement were read:
    $0

touist_smt: CARD IF VAR THEN XOR 
##
## Ends in an error in state: 245.
##
## if_statement(set_float) -> IF bool THEN . set_float ELSE set_float END [ WHEN RPAREN ELSE COMMA COLON ]
## if_statement(set_int) -> IF bool THEN . set_int ELSE set_int END [ WHEN RPAREN ELSE COMMA COLON ]
## if_statement(set_prop) -> IF bool THEN . set_prop ELSE set_prop END [ WHEN RPAREN ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IF bool THEN 
##

Ill-formed $3. At this point, a set of integer, float
or propositions is expected.
Instead, the following statement were read:
    $0

touist_smt: IF VAR THEN XOR 
##
## Ends in an error in state: 435.
##
## if_statement(float) -> IF bool THEN . float ELSE float END [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
## if_statement(formula_smt) -> IF bool THEN . formula_smt ELSE formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## if_statement(int) -> IF bool THEN . int ELSE int END [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
##
## The known suffix of the stack is as follows:
## IF bool THEN 
##

Ill-formed $3. At this point, a float or a formula or an int is expected.
Instead, the following statement were read:
    $0

touist_smt: SQRT IF VAR THEN XOR 
##
## Ends in an error in state: 291.
##
## if_statement(float) -> IF bool THEN . float ELSE float END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN 
##

Ill-formed $3. At this point, a float or a formula or an int is expected.
Instead, the following statement were read:
    $0


# Ill-formed $3. At this point, a bool, float, int or a set is expected.
# Instead, the following statement were read:
#     $0
touist_simple: EXACT IF VAR THEN XOR 
##
## Ends in an error in state: 234.
##
## if_statement(int) -> IF bool THEN . int ELSE int END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN 
##

Ill-formed $3. At this point, an int is expected.
Instead, the following statement were read:
    $0

touist_simple: IF FLOAT IN IF VAR THEN XOR 
##
## Ends in an error in state: 138.
##
## if_statement(set_float) -> IF bool THEN . set_float ELSE set_float END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN 
##

Ill-formed $3. At this point, a boolean is expeted.
Instead, the following statement were read:
    $0

touist_simple: IF IF VAR THEN XOR 
##
## Ends in an error in state: 258.
##
## if_statement(bool) -> IF bool THEN . bool ELSE bool END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## if_statement(float) -> IF bool THEN . float ELSE float END [ SUB RPAREN NOTEQUAL MUL MOD LT LE IN GT GE EQUAL ELSE DIV ADD ]
## if_statement(int) -> IF bool THEN . int ELSE int END [ SUB RPAREN NOTEQUAL MUL MOD LT LE IN GT GE EQUAL ELSE DIV ADD ]
##
## The known suffix of the stack is as follows:
## IF bool THEN 
##

Ill-formed $3. At this point, a boolean, float or int is expected.
Instead, the following statement were read:
    $0

touist_simple: IF INT IN IF VAR THEN XOR 
##
## Ends in an error in state: 177.
##
## if_statement(set_int) -> IF bool THEN . set_int ELSE set_int END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN 
##

Ill-formed $3. At this point, a set of integers is expected.
Instead, the following statement were read:
    $0

touist_simple: IF VAR IN IF VAR THEN XOR 
##
## Ends in an error in state: 208.
##
## if_statement(set_prop) -> IF bool THEN . set_prop ELSE set_prop END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN 
##

Ill-formed $3. At this point, a set of propositions is expected.
Instead, the following statement were read:
    $0

touist_simple: IF VAR THEN XOR 
##
## Ends in an error in state: 321.
##
## if_statement(formula_simple) -> IF bool THEN . formula_simple ELSE formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## IF bool THEN 
##

Ill-formed $3. At this point, a formula is expected.
Instead, the following statement were read:
    $0

touist_simple: TUPLE IF VAR THEN XOR 
##
## Ends in an error in state: 275.
##
## if_statement(float) -> IF bool THEN . float ELSE float END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## if_statement(int) -> IF bool THEN . int ELSE int END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN 
##

Ill-formed $3. At this point, an int or float is expected.
Instead, the following statement were read:
    $0

touist_smt: CARD IF VAR VARTUPLE 
##
## Ends in an error in state: 244.
##
## connectors(bool) -> bool . AND bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . OR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . XOR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . IMPLIES bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . EQUIV bool [ XOR THEN OR IMPLIES EQUIV AND ]
## if_statement(set_float) -> IF bool . THEN set_float ELSE set_float END [ WHEN RPAREN ELSE COMMA COLON ]
## if_statement(set_int) -> IF bool . THEN set_int ELSE set_int END [ WHEN RPAREN ELSE COMMA COLON ]
## if_statement(set_prop) -> IF bool . THEN set_prop ELSE set_prop END [ WHEN RPAREN ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IF bool 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production bool -> var 
##
touist_smt: IF VAR VARTUPLE 
##
## Ends in an error in state: 434.
##
## connectors(bool) -> bool . AND bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . OR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . XOR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . IMPLIES bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . EQUIV bool [ XOR THEN OR IMPLIES EQUIV AND ]
## if_statement(float) -> IF bool . THEN float ELSE float END [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
## if_statement(formula_smt) -> IF bool . THEN formula_smt ELSE formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## if_statement(int) -> IF bool . THEN int ELSE int END [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
##
## The known suffix of the stack is as follows:
## IF bool 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production bool -> var 
##
touist_smt: SQRT IF VAR VARTUPLE 
##
## Ends in an error in state: 290.
##
## connectors(bool) -> bool . AND bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . OR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . XOR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . IMPLIES bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . EQUIV bool [ XOR THEN OR IMPLIES EQUIV AND ]
## if_statement(float) -> IF bool . THEN float ELSE float END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## IF bool 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production bool -> var 
##
touist_simple: VAR AFFECT IF VAR VARTUPLE 
##
## Ends in an error in state: 399.
##
## connectors(bool) -> bool . AND bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . OR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . XOR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . IMPLIES bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . EQUIV bool [ XOR THEN OR IMPLIES EQUIV AND ]
## if_statement(bool) -> IF bool . THEN bool ELSE bool END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF ELSE CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## if_statement(float) -> IF bool . THEN float ELSE float END [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF ELSE DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## if_statement(int) -> IF bool . THEN int ELSE int END [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF ELSE DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## if_statement(set_float) -> IF bool . THEN set_float ELSE set_float END [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## if_statement(set_int) -> IF bool . THEN set_int ELSE set_int END [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## if_statement(set_prop) -> IF bool . THEN set_prop ELSE set_prop END [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
##
## The known suffix of the stack is as follows:
## IF bool 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production bool -> var 
##
touist_simple: EXACT IF VAR VARTUPLE 
##
## Ends in an error in state: 233.
##
## connectors(bool) -> bool . AND bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . OR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . XOR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . IMPLIES bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . EQUIV bool [ XOR THEN OR IMPLIES EQUIV AND ]
## if_statement(int) -> IF bool . THEN int ELSE int END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## IF bool 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production bool -> var 
##
touist_simple: IF FLOAT IN IF VAR VARTUPLE 
##
## Ends in an error in state: 135.
##
## connectors(bool) -> bool . AND bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . OR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . XOR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . IMPLIES bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . EQUIV bool [ XOR THEN OR IMPLIES EQUIV AND ]
## if_statement(set_float) -> IF bool . THEN set_float ELSE set_float END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production bool -> var 
##
touist_simple: IF IF VAR VARTUPLE 
##
## Ends in an error in state: 257.
##
## connectors(bool) -> bool . AND bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . OR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . XOR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . IMPLIES bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . EQUIV bool [ XOR THEN OR IMPLIES EQUIV AND ]
## if_statement(bool) -> IF bool . THEN bool ELSE bool END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## if_statement(float) -> IF bool . THEN float ELSE float END [ SUB RPAREN NOTEQUAL MUL MOD LT LE IN GT GE EQUAL ELSE DIV ADD ]
## if_statement(int) -> IF bool . THEN int ELSE int END [ SUB RPAREN NOTEQUAL MUL MOD LT LE IN GT GE EQUAL ELSE DIV ADD ]
##
## The known suffix of the stack is as follows:
## IF bool 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production bool -> var 
##
touist_simple: IF INT IN IF VAR VARTUPLE 
##
## Ends in an error in state: 176.
##
## connectors(bool) -> bool . AND bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . OR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . XOR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . IMPLIES bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . EQUIV bool [ XOR THEN OR IMPLIES EQUIV AND ]
## if_statement(set_int) -> IF bool . THEN set_int ELSE set_int END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production bool -> var 
##
touist_simple: IF VAR IN IF VAR VARTUPLE 
##
## Ends in an error in state: 207.
##
## connectors(bool) -> bool . AND bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . OR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . XOR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . IMPLIES bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . EQUIV bool [ XOR THEN OR IMPLIES EQUIV AND ]
## if_statement(set_prop) -> IF bool . THEN set_prop ELSE set_prop END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production bool -> var 
##
touist_simple: IF VAR VARTUPLE 
##
## Ends in an error in state: 320.
##
## connectors(bool) -> bool . AND bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . OR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . XOR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . IMPLIES bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . EQUIV bool [ XOR THEN OR IMPLIES EQUIV AND ]
## if_statement(formula_simple) -> IF bool . THEN formula_simple ELSE formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## IF bool 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production bool -> var 
##
touist_simple: TUPLE IF VAR VARTUPLE 
##
## Ends in an error in state: 274.
##
## connectors(bool) -> bool . AND bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . OR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . XOR bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . IMPLIES bool [ XOR THEN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . EQUIV bool [ XOR THEN OR IMPLIES EQUIV AND ]
## if_statement(float) -> IF bool . THEN float ELSE float END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## if_statement(int) -> IF bool . THEN int ELSE int END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## IF bool 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production bool -> var 
##

Ill-formed $2. At this point, $2 expects either 'then' or a continuation
of the boolean expression started with
    $1
using one of the following operators:
    and, or, xor, =>, <=>.
Instead, the following statement were read:
    $0

touist_simple: VAR AFFECT BOOL WHEN 
##
## Ends in an error in state: 407.
##
## connectors(bool) -> bool . AND bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . OR bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . XOR bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . IMPLIES bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . EQUIV bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## global_affect_types -> bool . [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
##
## The known suffix of the stack is as follows:
## bool 
##

Ill-formed boolean expression: at this point, expecting a
continuation of the boolean expression started with
    $1
using one of the following operators:
    and, or, xor, =>, <=>.
or finish the affectation with a new variable affectation.
Instead, the following statement were read:
    $0

touist_smt: CARD IF XOR 
##
## Ends in an error in state: 27.
##
## if_statement(set_float) -> IF . bool THEN set_float ELSE set_float END [ WHEN RPAREN ELSE COMMA COLON ]
## if_statement(set_int) -> IF . bool THEN set_int ELSE set_int END [ WHEN RPAREN ELSE COMMA COLON ]
## if_statement(set_prop) -> IF . bool THEN set_prop ELSE set_prop END [ WHEN RPAREN ELSE COMMA COLON ]
##
## The known suffix of the stack is as follows:
## IF 
##
touist_smt: IF XOR 
##
## Ends in an error in state: 433.
##
## if_statement(float) -> IF . bool THEN float ELSE float END [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
## if_statement(formula_smt) -> IF . bool THEN formula_smt ELSE formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## if_statement(int) -> IF . bool THEN int ELSE int END [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
##
## The known suffix of the stack is as follows:
## IF 
##
touist_smt: SQRT IF XOR 
##
## Ends in an error in state: 10.
##
## if_statement(float) -> IF . bool THEN float ELSE float END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## IF 
##
touist_simple: EXACT IF XOR 
##
## Ends in an error in state: 39.
##
## if_statement(int) -> IF . bool THEN int ELSE int END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## IF 
##
touist_simple: IF FLOAT IN IF XOR 
##
## Ends in an error in state: 130.
##
## if_statement(set_float) -> IF . bool THEN set_float ELSE set_float END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF 
##
touist_simple: IF IF XOR 
##
## Ends in an error in state: 20.
##
## if_statement(bool) -> IF . bool THEN bool ELSE bool END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## if_statement(float) -> IF . bool THEN float ELSE float END [ SUB RPAREN NOTEQUAL MUL MOD LT LE IN GT GE EQUAL ELSE DIV ADD ]
## if_statement(int) -> IF . bool THEN int ELSE int END [ SUB RPAREN NOTEQUAL MUL MOD LT LE IN GT GE EQUAL ELSE DIV ADD ]
##
## The known suffix of the stack is as follows:
## IF 
##
touist_simple: IF INT IN IF XOR 
##
## Ends in an error in state: 90.
##
## if_statement(set_int) -> IF . bool THEN set_int ELSE set_int END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF 
##
touist_simple: IF VAR IN IF XOR 
##
## Ends in an error in state: 55.
##
## if_statement(set_prop) -> IF . bool THEN set_prop ELSE set_prop END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF 
##
touist_simple: IF XOR 
##
## Ends in an error in state: 319.
##
## if_statement(formula_simple) -> IF . bool THEN formula_simple ELSE formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## IF 
##
touist_simple: TUPLE IF XOR 
##
## Ends in an error in state: 17.
##
## if_statement(float) -> IF . bool THEN float ELSE float END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## if_statement(int) -> IF . bool THEN int ELSE int END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## IF 
##
touist_simple: VAR AFFECT IF XOR 
##
## Ends in an error in state: 398.
##
## if_statement(bool) -> IF . bool THEN bool ELSE bool END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF ELSE CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## if_statement(float) -> IF . bool THEN float ELSE float END [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF ELSE DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## if_statement(int) -> IF . bool THEN int ELSE int END [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF ELSE DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## if_statement(set_float) -> IF . bool THEN set_float ELSE set_float END [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## if_statement(set_int) -> IF . bool THEN set_int ELSE set_int END [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## if_statement(set_prop) -> IF . bool THEN set_prop ELSE set_prop END [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
##
## The known suffix of the stack is as follows:
## IF 
##

Ill-formed $1. At this point, a boolean expression is expected.
Instead, the following statement were read:
    $0

touist_smt: CARD LBRACK FLOAT COMMA XOR 
##
## Ends in an error in state: 124.
##
## comma_list(float) -> float COMMA . comma_list(float) [ RBRACK ]
##
## The known suffix of the stack is as follows:
## float COMMA 
##

Ill-formed comma-separated list of floats. At this point, a float is expected.
Instead, the following statement were read:
    $0

touist_smt: CARD LBRACK INT COMMA XOR 
##
## Ends in an error in state: 84.
##
## comma_list(int) -> int COMMA . comma_list(int) [ RBRACK ]
##
## The known suffix of the stack is as follows:
## int COMMA 
##

Ill-formed comma-separated list of integers. At this point, an integer is expected.
Instead, the following statement were read:
    $0

touist_smt: CARD LBRACK VAR COMMA XOR 
##
## Ends in an error in state: 50.
##
## comma_list(prop) -> prop COMMA . comma_list(prop) [ RBRACK ]
##
## The known suffix of the stack is as follows:
## prop COMMA 
##

Ill-formed comma-separated list of propositions. At this point, a proposition is expected.
Instead, the following statement were read:
    $0

touist_simple: BIGOR VAR COMMA XOR 
##
## Ends in an error in state: 330.
##
## comma_list(var) -> var COMMA . comma_list(var) [ IN ]
##
## The known suffix of the stack is as follows:
## var COMMA 
##

Ill-formed comma-separated list of variables. At this point, a variable is expected.
Instead, the following statement were read:
    $0

touist_simple: TUPLE VAR COMMA XOR 
##
## Ends in an error in state: 304.
##
## comma_list(indices) -> indices COMMA . comma_list(indices) [ RPAREN ]
##
## The known suffix of the stack is as follows:
## indices COMMA 
##

Ill-formed comma-separated list of indices. At this point, a variable is expected.
An index must of of type integer, float or proposition.
Instead, the following statement were read:
    $0

touist_simple: BIGOR VAR IN LBRACK INT RBRACK COMMA XOR 
##
## Ends in an error in state: 378.
##
## comma_list(any_set) -> any_set COMMA . comma_list(any_set) [ WHEN COLON ]
##
## The known suffix of the stack is as follows:
## any_set COMMA 
##

Ill-formed comma-separated list of sets. At this point, a set is expected.
Instead, the following statement were read:
    $0

touist_smt: FLOAT ADD XOR 
##
## Ends in an error in state: 108.
##
## num_operations_standard(float) -> float ADD . float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## float ADD 
##
touist_smt: FLOAT DIV XOR 
##
## Ends in an error in state: 106.
##
## num_operations_standard(float) -> float DIV . float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## float DIV 
##
touist_smt: FLOAT MOD XOR 
##
## Ends in an error in state: 104.
##
## num_operations_others(float) -> float MOD . float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## float MOD 
##
touist_smt: FLOAT MUL XOR 
##
## Ends in an error in state: 102.
##
## num_operations_standard(float) -> float MUL . float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## float MUL 
##
touist_smt: FLOAT SUB XOR 
##
## Ends in an error in state: 97.
##
## num_operations_standard(float) -> float SUB . float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## float SUB 
##
touist_simple: IF FLOAT EQUAL XOR 
##
## Ends in an error in state: 174.
##
## equality(float) -> float EQUAL . float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## float EQUAL 
##
touist_simple: IF FLOAT GE XOR 
##
## Ends in an error in state: 172.
##
## order(float) -> float GE . float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## float GE 
##
touist_simple: IF FLOAT GT XOR 
##
## Ends in an error in state: 170.
##
## order(float) -> float GT . float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## float GT 
##
touist_simple: IF FLOAT LE XOR 
##
## Ends in an error in state: 115.
##
## order(float) -> float LE . float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## float LE 
##
touist_simple: IF FLOAT LT XOR 
##
## Ends in an error in state: 113.
##
## order(float) -> float LT . float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## float LT 
##
touist_simple: IF FLOAT NOTEQUAL XOR 
##
## Ends in an error in state: 111.
##
## equality(float) -> float NOTEQUAL . float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## float NOTEQUAL 
##

Ill-formed $1 operator. At this point, a float is expected.
This type is required because the left-operand is of type float:
    $2
Instead, the following statement were read:
    $0


touist_simple: IF FLOAT IN XOR 
##
## Ends in an error in state: 117.
##
## in_operator -> float IN . set_float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## float IN 
##

Ill-formed $1 operator. At this point, a set of floats is expected.
This type of set is required because the left-operand is of type float:
    $2
Instead, the following statement were read:
    $0

touist_simple: IF INT IN XOR 
##
## Ends in an error in state: 77.
##
## in_operator -> int IN . set_int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## int IN 
##

Ill-formed $1 operator. At this point, a set of integers is expected.
This type of set is required because the left-operand is of type integers:
    $2
Instead, the following statement were read:
    $0

touist_simple: IF VAR IN XOR 
##
## Ends in an error in state: 46.
##
## in_operator -> prop IN . set_prop [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## prop IN 
##

Ill-formed $1 operator. At this point, a set of propositions is expected.
This type of set is required because the left-operand is of type proposition:
    $2
Instead, the following statement were read:
    $0

touist_smt: CARD LBRACK FLOAT RANGE VAR XOR 
##
## Ends in an error in state: 122.
##
## num_operations_others(float) -> float . MOD float [ SUB RBRACK MUL MOD DIV ADD ]
## num_operations_standard(float) -> float . ADD float [ SUB RBRACK MUL MOD DIV ADD ]
## num_operations_standard(float) -> float . SUB float [ SUB RBRACK MUL MOD DIV ADD ]
## num_operations_standard(float) -> float . MUL float [ SUB RBRACK MUL MOD DIV ADD ]
## num_operations_standard(float) -> float . DIV float [ SUB RBRACK MUL MOD DIV ADD ]
## set_decl_range(float) -> LBRACK float RANGE float . RBRACK [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LBRACK float RANGE float 
##

Ill-formed $2 operator. At this point, either finish with ']'
or continue the float expression that was started with:
    $1
Instead, the following statement were read:
    $0

touist_smt: CARD LBRACK VAR RANGE VAR XOR 
##
## Ends in an error in state: 82.
##
## num_operations_others(int) -> int . MOD int [ SUB RBRACK MUL MOD DIV ADD ]
## num_operations_standard(int) -> int . ADD int [ SUB RBRACK MUL MOD DIV ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB RBRACK MUL MOD DIV ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB RBRACK MUL MOD DIV ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB RBRACK MUL MOD DIV ADD ]
## set_decl_range(int) -> LBRACK int RANGE int . RBRACK [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LBRACK int RANGE int 
##

Ill-formed $2 operator. At this point, either finish with ']'
or continue the integer expression that was started with:
    $1
Instead, the following statement were read:
    $0

touist_smt: CARD LBRACK FLOAT RANGE XOR 
##
## Ends in an error in state: 121.
##
## set_decl_range(float) -> LBRACK float RANGE . float RBRACK [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LBRACK float RANGE 
##

Ill-formed $1 operator. At this point, a float is expected.
Instead, the following statement were read:
    $0

touist_smt: CARD LBRACK VAR RANGE XOR 
##
## Ends in an error in state: 81.
##
## set_decl_range(int) -> LBRACK int RANGE . int RBRACK [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LBRACK int RANGE 
##

Ill-formed $1 operator. At this point, an integer is expected.
Instead, the following statement were read:
    $0

touist_smt: CARD LBRACK FLOAT XOR 
##
## Ends in an error in state: 127.
##
## set_decl_explicit(float) -> LBRACK comma_list(float) . RBRACK [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LBRACK comma_list(float) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 120, spurious reduction of production comma_list(float) -> float 
##

Ill-formed set definition. At this point, either finish with ']' or continue
with a ',' the comma-separated list of floats started with:
    $1
Instead, the following statement were read:
    $0

touist_smt: CARD LBRACK INT XOR 
##
## Ends in an error in state: 87.
##
## set_decl_explicit(int) -> LBRACK comma_list(int) . RBRACK [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LBRACK comma_list(int) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 80, spurious reduction of production comma_list(int) -> int 
##

Ill-formed set definition. At this point, either finish with ']' or continue
with a ',' the comma-separated list of integers started with:
    $1
Instead, the following statement were read:
    $0

touist_smt: CARD LBRACK VAR XOR 
##
## Ends in an error in state: 52.
##
## set_decl_explicit(prop) -> LBRACK comma_list(prop) . RBRACK [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LBRACK comma_list(prop) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 254, spurious reduction of production prop -> var 
## In state 49, spurious reduction of production comma_list(prop) -> prop 
##

Ill-formed set definition. At this point, either finish with ']' or continue
with a ',' the comma-separated list of propositions started with:
    $1
Instead, the following statement were read:
    $0

touist_smt: INT SUB XOR 
##
## Ends in an error in state: 36.
##
## num_operations_standard(int) -> int SUB . int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## int SUB 
##
touist_smt: VAR ADD XOR 
##
## Ends in an error in state: 71.
##
## num_operations_standard(int) -> int ADD . int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## int ADD 
##
touist_smt: VAR DIV XOR 
##
## Ends in an error in state: 69.
##
## num_operations_standard(int) -> int DIV . int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## int DIV 
##
touist_smt: VAR MOD XOR 
##
## Ends in an error in state: 67.
##
## num_operations_others(int) -> int MOD . int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## int MOD 
##
touist_smt: VAR MUL XOR 
##
## Ends in an error in state: 65.
##
## num_operations_standard(int) -> int MUL . int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## int MUL 
##
touist_simple: IF INT EQUAL XOR 
##
## Ends in an error in state: 205.
##
## equality(int) -> int EQUAL . int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## int EQUAL 
##
touist_simple: IF INT NOTEQUAL XOR 
##
## Ends in an error in state: 59.
##
## equality(int) -> int NOTEQUAL . int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## int NOTEQUAL 
##
touist_simple: IF VAR GE XOR 
##
## Ends in an error in state: 203.
##
## order(int) -> int GE . int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## int GE 
##
touist_simple: IF VAR GT XOR 
##
## Ends in an error in state: 201.
##
## order(int) -> int GT . int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## int GT 
##
touist_simple: IF VAR LE XOR 
##
## Ends in an error in state: 75.
##
## order(int) -> int LE . int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## int LE 
##
touist_simple: IF VAR LT XOR 
##
## Ends in an error in state: 73.
##
## order(int) -> int LT . int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## int LT 
##

Ill-formed $1 operator. At this point, an integer is expected.
This type is required because the left-operand is of type integer:
    $2
Instead, the following statement were read:
    $0

touist_simple: IF VAR EQUAL XOR 
##
## Ends in an error in state: 231.
##
## equality(prop) -> prop EQUAL . prop [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## prop EQUAL 
##
touist_simple: IF VAR NOTEQUAL XOR 
##
## Ends in an error in state: 43.
##
## equality(prop) -> prop NOTEQUAL . prop [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## prop NOTEQUAL 
##

Ill-formed $1 operator. At this point, a proposition is expected.
This type is required because the left-operand is of type proposition:
    $2
Instead, the following statement were read:
    $0

touist_smt: CARD LBRACK XOR 
##
## Ends in an error in state: 23.
##
## set_decl_explicit(float) -> LBRACK . comma_list(float) RBRACK [ WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOT LPAREN LET INT IF FLOAT EXACT EOF COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## set_decl_explicit(int) -> LBRACK . comma_list(int) RBRACK [ WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOT LPAREN LET INT IF FLOAT EXACT EOF COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## set_decl_explicit(prop) -> LBRACK . comma_list(prop) RBRACK [ WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOT LPAREN LET INT IF FLOAT EXACT EOF COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## set_decl_range(float) -> LBRACK . float RANGE float RBRACK [ WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOT LPAREN LET INT IF FLOAT EXACT EOF COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## set_decl_range(int) -> LBRACK . int RANGE int RBRACK [ WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOT LPAREN LET INT IF FLOAT EXACT EOF COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## set_empty -> LBRACK . RBRACK [ WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOT LPAREN LET INT IF FLOAT EXACT EOF COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
##
## The known suffix of the stack is as follows:
## LBRACK 
##

Ill-formed set definition. At this point is expected one of the following:
- a comma-separated of floats, integers or propositions
- a float or integer followed by '..'
Instead, the following statement were read:
    $0

touist_simple: IF FLOAT IN LBRACK XOR 
##
## Ends in an error in state: 119.
##
## set_decl_explicit(float) -> LBRACK . comma_list(float) RBRACK [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## set_decl_range(float) -> LBRACK . float RANGE float RBRACK [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LBRACK 
##

Ill-formed set of floats definition. At this point is expected one of the following:
- a comma-separated of floats
- a float followed by '..'
Instead, the following statement were read:
    $0

touist_simple: IF INT IN LBRACK XOR 
##
## Ends in an error in state: 79.
##
## set_decl_explicit(int) -> LBRACK . comma_list(int) RBRACK [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## set_decl_range(int) -> LBRACK . int RANGE int RBRACK [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LBRACK 
##

Ill-formed set of integers definition. At this point is expected one of the following:
- a comma-separated of integers
- an integer followed by '..'
Instead, the following statement were read:
    $0

touist_simple: IF SUBSET LBRACK XOR 
##
## Ends in an error in state: 14.
##
## set_decl_explicit(float) -> LBRACK . comma_list(float) RBRACK [ ELSE COMMA ]
## set_decl_explicit(int) -> LBRACK . comma_list(int) RBRACK [ ELSE COMMA ]
## set_decl_explicit(prop) -> LBRACK . comma_list(prop) RBRACK [ ELSE COMMA ]
## set_decl_range(float) -> LBRACK . float RANGE float RBRACK [ ELSE COMMA ]
## set_decl_range(int) -> LBRACK . int RANGE int RBRACK [ ELSE COMMA ]
##
## The known suffix of the stack is as follows:
## LBRACK 
##

Ill-formed set definition. At this point is expected one of the following:
- a comma-separated of integers, floats or propositions
- an integer or float followed by '..'
Instead, the following statement were read:
    $0

touist_simple: IF VAR IN LBRACK XOR 
##
## Ends in an error in state: 48.
##
## set_decl_explicit(prop) -> LBRACK . comma_list(prop) RBRACK [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LBRACK 
##

Ill-formed set of propositions definition. At this point is expected a
comma-separated of propositions.
Instead, the following statement were read:
    $0

touist_smt: CARD VAR XOR 
##
## Ends in an error in state: 252.
##
## int -> CARD any_set . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## CARD any_set 
##

Ill-formed $2. At this point, either finish with ')' or continue the
set expression.
Instead, the following statement were read:
    $0

touist_smt: FLOAT ADD VAR WHEN 
##
## Ends in an error in state: 109.
##
## num_operations_others(float) -> float . MOD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . ADD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float ADD float . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . SUB float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . MUL float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . DIV float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## float ADD float 
##
touist_smt: FLOAT DIV VAR WHEN 
##
## Ends in an error in state: 107.
##
## num_operations_others(float) -> float . MOD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . ADD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . SUB float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . MUL float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . DIV float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float DIV float . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## float DIV float 
##
touist_smt: FLOAT MUL VAR WHEN 
##
## Ends in an error in state: 103.
##
## num_operations_others(float) -> float . MOD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . ADD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . SUB float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . MUL float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float MUL float . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . DIV float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## float MUL float 
##
touist_smt: FLOAT SUB VAR WHEN 
##
## Ends in an error in state: 110.
##
## num_operations_others(float) -> float . MOD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . ADD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . SUB float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float SUB float . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . MUL float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . DIV float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## float SUB float 
##
touist_simple: IF FLOAT EQUAL VAR WHEN 
##
## Ends in an error in state: 175.
##
## equality(float) -> float EQUAL float . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## num_operations_others(float) -> float . MOD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . ADD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . SUB float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . MUL float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . DIV float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## float EQUAL float 
##
touist_simple: IF FLOAT GE VAR WHEN 
##
## Ends in an error in state: 173.
##
## num_operations_others(float) -> float . MOD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . ADD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . SUB float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . MUL float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . DIV float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## order(float) -> float GE float . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## float GE float 
##
touist_simple: IF FLOAT GT VAR WHEN 
##
## Ends in an error in state: 171.
##
## num_operations_others(float) -> float . MOD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . ADD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . SUB float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . MUL float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . DIV float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## order(float) -> float GT float . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## float GT float 
##
touist_simple: IF FLOAT LE VAR WHEN 
##
## Ends in an error in state: 116.
##
## num_operations_others(float) -> float . MOD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . ADD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . SUB float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . MUL float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . DIV float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## order(float) -> float LE float . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## float LE float 
##
touist_simple: IF FLOAT LT VAR WHEN 
##
## Ends in an error in state: 114.
##
## num_operations_others(float) -> float . MOD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . ADD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . SUB float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . MUL float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . DIV float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## order(float) -> float LT float . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## float LT float 
##
touist_simple: IF FLOAT NOTEQUAL VAR WHEN 
##
## Ends in an error in state: 112.
##
## equality(float) -> float NOTEQUAL float . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## num_operations_others(float) -> float . MOD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . ADD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . SUB float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . MUL float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . DIV float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## float NOTEQUAL float 
##

Ill-formed $2 operator. At this point is expected a continuation of the float
expression that was started with
    $1
using one of the following operators
    +, -, *, /, mod
This type is required because the left-operand is of type float:
    $3
Instead, the following statement were read:
    $0

touist_simple: IF FLOAT XOR 
##
## Ends in an error in state: 96.
##
## equality(float) -> float . EQUAL float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## equality(float) -> float . NOTEQUAL float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## in_operator -> float . IN set_float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## num_operations_others(float) -> float . MOD float [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## num_operations_standard(float) -> float . ADD float [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## num_operations_standard(float) -> float . SUB float [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## num_operations_standard(float) -> float . MUL float [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## num_operations_standard(float) -> float . DIV float [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## order(float) -> float . LT float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## order(float) -> float . LE float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## order(float) -> float . GT float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## order(float) -> float . GE float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## float 
##
touist_simple: VAR AFFECT FLOAT XOR 
##
## Ends in an error in state: 406.
##
## equality(float) -> float . EQUAL float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## equality(float) -> float . NOTEQUAL float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## in_operator -> float . IN set_float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## num -> float . [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## num_operations_others(float) -> float . MOD float [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## num_operations_standard(float) -> float . ADD float [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## num_operations_standard(float) -> float . SUB float [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## num_operations_standard(float) -> float . MUL float [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## num_operations_standard(float) -> float . DIV float [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## order(float) -> float . LT float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## order(float) -> float . LE float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## order(float) -> float . GT float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## order(float) -> float . GE float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## float 
##

Ill-formed float expression. At this point, a continuation of the expression is
expected with one of the following operators: 
    =, !=, in, +, -, *, /, mod, <, <=, >, >=
Instead, read the following statement:
    $0

touist_simple: TUPLE FLOAT XOR 
##
## Ends in an error in state: 305.
##
## indices -> float . [ RPAREN COMMA ]
## num_operations_others(float) -> float . MOD float [ SUB RPAREN MUL MOD DIV COMMA ADD ]
## num_operations_standard(float) -> float . ADD float [ SUB RPAREN MUL MOD DIV COMMA ADD ]
## num_operations_standard(float) -> float . SUB float [ SUB RPAREN MUL MOD DIV COMMA ADD ]
## num_operations_standard(float) -> float . MUL float [ SUB RPAREN MUL MOD DIV COMMA ADD ]
## num_operations_standard(float) -> float . DIV float [ SUB RPAREN MUL MOD DIV COMMA ADD ]
##
## The known suffix of the stack is as follows:
## float 
##
touist_smt: FLOAT WHEN 
##
## Ends in an error in state: 298.
##
## num -> float . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOTEQUAL NOT LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## num_operations_others(float) -> float . MOD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . ADD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . SUB float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . MUL float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . DIV float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## float 
##

Ill-formed float expression. At this point, a continuation of the expression is
expected with one of the following operators: 
    +, -, *, /, mod
Instead, read the following statement:
    $0

touist_smt: IF VAR THEN FLOAT ELSE XOR 
##
## Ends in an error in state: 261.
##
## if_statement(float) -> IF bool THEN float ELSE . float END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN float ELSE 
##

Ill-formed 'if'. After $1, a float expression is expected.
This type is required because the $3 statement was of type float:
    $2
Instead, read the following statement:
    $0

touist_smt: IF VAR THEN INT ELSE XOR 
##
## Ends in an error in state: 236.
##
## if_statement(int) -> IF bool THEN int ELSE . int END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN int ELSE 
##

Ill-formed 'if'. After $1, an integer expression is expected.
This type is required because the $3 statement was of type integer:
    $2
Instead, read the following statement:
    $0

touist_simple: IF IF VAR THEN BOOL ELSE XOR 
##
## Ends in an error in state: 265.
##
## if_statement(bool) -> IF bool THEN bool ELSE . bool END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN bool ELSE 
##

Ill-formed 'if'. After $1, an boolean expression is expected.
This type is required because the $3 statement was of type boolean:
    $2
Instead, read the following statement:
    $0

touist_smt: IF VAR THEN VAR ELSE XOR 
##
## Ends in an error in state: 505.
##
## if_statement(formula_smt) -> IF bool THEN formula_smt ELSE . formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN formula_smt ELSE 
##
touist_simple: IF VAR THEN VAR ELSE XOR 
##
## Ends in an error in state: 383.
##
## if_statement(formula_simple) -> IF bool THEN formula_simple ELSE . formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## IF bool THEN formula_simple ELSE 
##

Ill-formed 'if'. After $1, a formula is expected.
This type is required because the $3 statement was of type formula:
    $2
Instead, read the following statement:
    $0

touist_smt: CARD IF VAR THEN LBRACK INT RBRACK ELSE XOR 
##
## Ends in an error in state: 189.
##
## if_statement(set_int) -> IF bool THEN set_int ELSE . set_int END [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN set_int ELSE 
##

Ill-formed 'if'. After $1, a set of integers is expected.
This type is required because the $3 statement was of type set of integers:
    $2
Instead, read the following statement:
    $0

touist_smt: CARD IF VAR THEN LBRACK TERM RBRACK ELSE XOR 
##
## Ends in an error in state: 219.
##
## if_statement(set_prop) -> IF bool THEN set_prop ELSE . set_prop END [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN set_prop ELSE 
##

Ill-formed 'if'. After $1, a set of propositions is expected.
This type is required because the $3 statement was of type set of propositions:
    $2
Instead, read the following statement:
    $0

touist_smt: CARD IF VAR THEN VAR ELSE XOR 
##
## Ends in an error in state: 150.
##
## if_statement(set_float) -> IF bool THEN set_float ELSE . set_float END [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN set_float ELSE 
##

Ill-formed 'if'. After $1, a set of floats is expected.
This type is required because the $3 statement was of type set of floats:
    $2
Instead, read the following statement:
    $0

touist_smt: IF VAR THEN FLOAT XOR 
##
## Ends in an error in state: 508.
##
## if_statement(float) -> IF bool THEN float . ELSE float END [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
## num -> float . [ NOTEQUAL LT LE GT GE EQUAL ]
## num_operations_others(float) -> float . MOD float [ SUB NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
## num_operations_standard(float) -> float . ADD float [ SUB NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
## num_operations_standard(float) -> float . SUB float [ SUB NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
## num_operations_standard(float) -> float . MUL float [ SUB NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
## num_operations_standard(float) -> float . DIV float [ SUB NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
##
## The known suffix of the stack is as follows:
## IF bool THEN float 
##

Ill-formed 'if'. At this point, either finish the 'then' with 'else'
or continue the float expression that was started with:
    $1
with one of the operators: 
    +, -, *, /, mod
Instead, read the following statement:
    $0

touist_smt: IF VAR THEN VAR RANGE 
##
## Ends in an error in state: 503.
##
## if_statement(int) -> IF bool THEN int . ELSE int END [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
## num -> int . [ NOTEQUAL LT LE GT GE EQUAL ]
## num_operations_others(int) -> int . MOD int [ SUB NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
## num_operations_standard(int) -> int . ADD int [ SUB NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
##
## The known suffix of the stack is as follows:
## IF bool THEN int 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 254, spurious reduction of production int -> var 
##

Ill-formed 'if'. At this point, either finish the 'then' with 'else'
or continue the integer expression that was started with:
    $1
with one of the operators: 
    +, -, *, /, mod
Instead, read the following statement:
    $0

touist_simple: IF IF VAR THEN FLOAT XOR 
##
## Ends in an error in state: 260.
##
## equality(float) -> float . EQUAL float [ XOR OR IMPLIES EQUIV ELSE AND ]
## equality(float) -> float . NOTEQUAL float [ XOR OR IMPLIES EQUIV ELSE AND ]
## if_statement(float) -> IF bool THEN float . ELSE float END [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF ELSE DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## in_operator -> float . IN set_float [ XOR OR IMPLIES EQUIV ELSE AND ]
## num_operations_others(float) -> float . MOD float [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL ELSE DIV ADD ]
## num_operations_standard(float) -> float . ADD float [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL ELSE DIV ADD ]
## num_operations_standard(float) -> float . SUB float [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL ELSE DIV ADD ]
## num_operations_standard(float) -> float . MUL float [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL ELSE DIV ADD ]
## num_operations_standard(float) -> float . DIV float [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL ELSE DIV ADD ]
## order(float) -> float . LT float [ XOR OR IMPLIES EQUIV ELSE AND ]
## order(float) -> float . LE float [ XOR OR IMPLIES EQUIV ELSE AND ]
## order(float) -> float . GT float [ XOR OR IMPLIES EQUIV ELSE AND ]
## order(float) -> float . GE float [ XOR OR IMPLIES EQUIV ELSE AND ]
##
## The known suffix of the stack is as follows:
## IF bool THEN float 
##

Ill-formed 'if'. At this point, either finish the 'then' with 'else'
or continue the float expression that was started with:
    $1
with one of the operators: 
    +, -, *, /, mod,<,<=,>=,>,==,!=,in
Instead, read the following statement:
    $0

touist_simple: IF IF VAR THEN VAR RPAREN 
##
## Ends in an error in state: 259.
##
## equality(int) -> int . EQUAL int [ XOR OR IMPLIES EQUIV ELSE AND ]
## equality(int) -> int . NOTEQUAL int [ XOR OR IMPLIES EQUIV ELSE AND ]
## if_statement(int) -> IF bool THEN int . ELSE int END [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF ELSE DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## in_operator -> int . IN set_int [ XOR OR IMPLIES EQUIV ELSE AND ]
## num_operations_others(int) -> int . MOD int [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL ELSE DIV ADD ]
## num_operations_standard(int) -> int . ADD int [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL ELSE DIV ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL ELSE DIV ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL ELSE DIV ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL ELSE DIV ADD ]
## order(int) -> int . LT int [ XOR OR IMPLIES EQUIV ELSE AND ]
## order(int) -> int . LE int [ XOR OR IMPLIES EQUIV ELSE AND ]
## order(int) -> int . GT int [ XOR OR IMPLIES EQUIV ELSE AND ]
## order(int) -> int . GE int [ XOR OR IMPLIES EQUIV ELSE AND ]
##
## The known suffix of the stack is as follows:
## IF bool THEN int 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production int -> var 
##

Ill-formed 'if'. At this point, either finish the 'then' with 'else'
or continue the integer expression that was started with:
    $1
with one of the operators: 
    +, -, *, /, mod,<,<=,>=,>,==,!=,in
Instead, read the following statement:
    $0

touist_simple: IF IF VAR THEN VAR VARTUPLE 
##
## Ends in an error in state: 264.
##
## connectors(bool) -> bool . AND bool [ XOR OR IMPLIES EQUIV ELSE AND ]
## connectors(bool) -> bool . OR bool [ XOR OR IMPLIES EQUIV ELSE AND ]
## connectors(bool) -> bool . XOR bool [ XOR OR IMPLIES EQUIV ELSE AND ]
## connectors(bool) -> bool . IMPLIES bool [ XOR OR IMPLIES EQUIV ELSE AND ]
## connectors(bool) -> bool . EQUIV bool [ XOR OR IMPLIES EQUIV ELSE AND ]
## if_statement(bool) -> IF bool THEN bool . ELSE bool END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN bool 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production bool -> var 
##

Ill-formed 'if'. At this point, either finish the 'then' with 'else'
or continue the boolean expression that was started with:
    $1
with one of the operators:
    and, or, xor, =>, <=>
Instead, read the following statement:
    $0

touist_simple: TUPLE IF VAR THEN FLOAT XOR 
##
## Ends in an error in state: 276.
##
## if_statement(float) -> IF bool THEN float . ELSE float END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_others(float) -> float . MOD float [ SUB MUL MOD ELSE DIV ADD ]
## num_operations_standard(float) -> float . ADD float [ SUB MUL MOD ELSE DIV ADD ]
## num_operations_standard(float) -> float . SUB float [ SUB MUL MOD ELSE DIV ADD ]
## num_operations_standard(float) -> float . MUL float [ SUB MUL MOD ELSE DIV ADD ]
## num_operations_standard(float) -> float . DIV float [ SUB MUL MOD ELSE DIV ADD ]
##
## The known suffix of the stack is as follows:
## IF bool THEN float 
##

Ill-formed 'if'. At this point, either finish the 'then' with 'else'
or continue the float expression that was started with:
    $1
with one of the operators:
    +, -, *, /, mod
Instead, read the following statement:
    $0

touist_simple: TUPLE IF VAR THEN VAR XOR 
##
## Ends in an error in state: 235.
##
## if_statement(int) -> IF bool THEN int . ELSE int END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_others(int) -> int . MOD int [ SUB MUL MOD ELSE DIV ADD ]
## num_operations_standard(int) -> int . ADD int [ SUB MUL MOD ELSE DIV ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB MUL MOD ELSE DIV ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB MUL MOD ELSE DIV ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB MUL MOD ELSE DIV ADD ]
##
## The known suffix of the stack is as follows:
## IF bool THEN int 
##

Ill-formed 'if'. At this point, either finish the 'then' with 'else'
or continue the integer expression that was started with:
    $1
with one of the operators:
    +, -, *, /, mod
Instead, read the following statement:
    $0

touist_smt: IF VAR THEN VAR VARTUPLE 
##
## Ends in an error in state: 504.
##
## connectors(formula_smt) -> formula_smt . AND formula_smt [ XOR OR IMPLIES EQUIV ELSE AND ]
## connectors(formula_smt) -> formula_smt . OR formula_smt [ XOR OR IMPLIES EQUIV ELSE AND ]
## connectors(formula_smt) -> formula_smt . XOR formula_smt [ XOR OR IMPLIES EQUIV ELSE AND ]
## connectors(formula_smt) -> formula_smt . IMPLIES formula_smt [ XOR OR IMPLIES EQUIV ELSE AND ]
## connectors(formula_smt) -> formula_smt . EQUIV formula_smt [ XOR OR IMPLIES EQUIV ELSE AND ]
## if_statement(formula_smt) -> IF bool THEN formula_smt . ELSE formula_smt END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN formula_smt 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 254, spurious reduction of production prop -> var 
## In state 464, spurious reduction of production formula(formula_smt) -> prop 
## In state 475, spurious reduction of production formula_smt -> formula(formula_smt) 
##
touist_simple: IF VAR THEN VAR WHEN 
##
## Ends in an error in state: 382.
##
## connectors(formula_simple) -> formula_simple . AND formula_simple [ XOR OR IMPLIES EQUIV ELSE AND ]
## connectors(formula_simple) -> formula_simple . OR formula_simple [ XOR OR IMPLIES EQUIV ELSE AND ]
## connectors(formula_simple) -> formula_simple . XOR formula_simple [ XOR OR IMPLIES EQUIV ELSE AND ]
## connectors(formula_simple) -> formula_simple . IMPLIES formula_simple [ XOR OR IMPLIES EQUIV ELSE AND ]
## connectors(formula_simple) -> formula_simple . EQUIV formula_simple [ XOR OR IMPLIES EQUIV ELSE AND ]
## if_statement(formula_simple) -> IF bool THEN formula_simple . ELSE formula_simple END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## IF bool THEN formula_simple 
##

Ill-formed 'if'. At this point, either finish the 'then' with 'else'
or continue the integer expression that was started with
    $1
with one of the following operators
    and, or, xor, =>, <=>.
Instead, read the following statement:
    $0

touist_smt: INT SUB VAR WHEN 
##
## Ends in an error in state: 242.
##
## num_operations_others(int) -> int . MOD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . ADD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . SUB int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int SUB int . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . MUL int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . DIV int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## int SUB int 
##
touist_smt: VAR ADD VAR WHEN 
##
## Ends in an error in state: 72.
##
## num_operations_others(int) -> int . MOD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . ADD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int ADD int . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . SUB int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . MUL int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . DIV int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## int ADD int 
##
touist_smt: VAR DIV VAR WHEN 
##
## Ends in an error in state: 70.
##
## num_operations_others(int) -> int . MOD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . ADD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . SUB int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . MUL int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . DIV int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int DIV int . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## int DIV int 
##
touist_smt: VAR MUL VAR WHEN 
##
## Ends in an error in state: 66.
##
## num_operations_others(int) -> int . MOD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . ADD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . SUB int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . MUL int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int MUL int . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . DIV int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## int MUL int 
##

Ill-formed $2. At this point is expected a continuation of the integer
expression that was started with
    $1
using one of the following operators
    +, -, *, /, mod
This type is required because the left-operand is of type integer:
    $3
Instead, the following statement were read:
    $0

touist_smt: INT XOR 
##
## Ends in an error in state: 478.
##
## equality(any_atom) -> any_atom . EQUAL any_atom [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## equality(any_atom) -> any_atom . NOTEQUAL any_atom [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## order(any_atom) -> any_atom . LT any_atom [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## order(any_atom) -> any_atom . LE any_atom [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## order(any_atom) -> any_atom . GT any_atom [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## order(any_atom) -> any_atom . GE any_atom [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## any_atom 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 297, spurious reduction of production num -> int 
## In state 403, spurious reduction of production any_atom -> num 
##

Ill-formed atom expression. An atom can be either int, float or proposition.
At this point, a continuation of the atom expression is expected, using
the following operators:
    ==, !=, <, <=, >, >=
Instead, the following statement were read:
    $0

touist_smt: LET VAR AFFECT FLOAT COLON TOP WHEN 
##
## Ends in an error in state: 515.
##
## connectors(formula_smt) -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## let_affect(float,formula_smt) -> LET var AFFECT float COLON formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT float COLON formula_smt 
##
touist_simple: LET VAR AFFECT FLOAT COLON VAR WHEN 
##
## Ends in an error in state: 392.
##
## connectors(formula_simple) -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## let_affect(float,formula_simple) -> LET var AFFECT float COLON formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT float COLON formula_simple 
##
touist_smt: LET VAR AFFECT INT COLON TOP WHEN 
##
## Ends in an error in state: 512.
##
## connectors(formula_smt) -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## let_affect(int,formula_smt) -> LET var AFFECT int COLON formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT int COLON formula_smt 
##
touist_smt: LET VAR AFFECT VAR COLON TOP WHEN 
##
## Ends in an error in state: 509.
##
## connectors(formula_smt) -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## let_affect(prop,formula_smt) -> LET var AFFECT prop COLON formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT prop COLON formula_smt 
##
touist_simple: LET VAR AFFECT INT COLON VAR WHEN 
##
## Ends in an error in state: 389.
##
## connectors(formula_simple) -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## let_affect(int,formula_simple) -> LET var AFFECT int COLON formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT int COLON formula_simple 
##
touist_simple: LET VAR AFFECT VAR COLON VAR WHEN 
##
## Ends in an error in state: 386.
##
## connectors(formula_simple) -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## let_affect(prop,formula_simple) -> LET var AFFECT prop COLON formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT prop COLON formula_simple 
##

Ill-formed 'let' statement. At this point, a continuation of the
following formula is expected
    $1
using one of the following operators:
    and, or, xor, =>, <=>.
Instead, the following statement were read:
    $0

touist_smt: LET VAR AFFECT FLOAT COLON XOR 
##
## Ends in an error in state: 514.
##
## let_affect(float,formula_smt) -> LET var AFFECT float COLON . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT float COLON 
##
touist_simple: LET VAR AFFECT FLOAT COLON XOR 
##
## Ends in an error in state: 391.
##
## let_affect(float,formula_simple) -> LET var AFFECT float COLON . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT float COLON 
##
touist_smt: LET VAR AFFECT INT COLON XOR 
##
## Ends in an error in state: 511.
##
## let_affect(int,formula_smt) -> LET var AFFECT int COLON . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT int COLON 
##
touist_smt: LET VAR AFFECT VAR COLON XOR 
##
## Ends in an error in state: 432.
##
## let_affect(prop,formula_smt) -> LET var AFFECT prop COLON . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT prop COLON 
##
touist_simple: LET VAR AFFECT INT COLON XOR 
##
## Ends in an error in state: 388.
##
## let_affect(int,formula_simple) -> LET var AFFECT int COLON . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT int COLON 
##
touist_simple: LET VAR AFFECT VAR COLON XOR 
##
## Ends in an error in state: 318.
##
## let_affect(prop,formula_simple) -> LET var AFFECT prop COLON . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT prop COLON 
##

Ill-formed 'let' statement. At this point, a formula is expected.
Instead, the following statement were read:
    $0

touist_smt: LET VAR AFFECT FLOAT XOR 
##
## Ends in an error in state: 513.
##
## let_affect(float,formula_smt) -> LET var AFFECT float . COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## num_operations_others(float) -> float . MOD float [ SUB MUL MOD DIV COLON ADD ]
## num_operations_standard(float) -> float . ADD float [ SUB MUL MOD DIV COLON ADD ]
## num_operations_standard(float) -> float . SUB float [ SUB MUL MOD DIV COLON ADD ]
## num_operations_standard(float) -> float . MUL float [ SUB MUL MOD DIV COLON ADD ]
## num_operations_standard(float) -> float . DIV float [ SUB MUL MOD DIV COLON ADD ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT float 
##
touist_simple: LET VAR AFFECT FLOAT XOR 
##
## Ends in an error in state: 390.
##
## let_affect(float,formula_simple) -> LET var AFFECT float . COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## num_operations_others(float) -> float . MOD float [ SUB MUL MOD DIV COLON ADD ]
## num_operations_standard(float) -> float . ADD float [ SUB MUL MOD DIV COLON ADD ]
## num_operations_standard(float) -> float . SUB float [ SUB MUL MOD DIV COLON ADD ]
## num_operations_standard(float) -> float . MUL float [ SUB MUL MOD DIV COLON ADD ]
## num_operations_standard(float) -> float . DIV float [ SUB MUL MOD DIV COLON ADD ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT float 
##

Ill-formed 'let' statement. At this point, expected either ':' or a continuation
of the float expression started with:
    $1
using one of the following operators:
    +, -, *, /, mod
Instead, the following statement were read:
    $0

touist_smt: LET VAR AFFECT VAR RANGE 
##
## Ends in an error in state: 510.
##
## let_affect(int,formula_smt) -> LET var AFFECT int . COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## num_operations_others(int) -> int . MOD int [ SUB MUL MOD DIV COLON ADD ]
## num_operations_standard(int) -> int . ADD int [ SUB MUL MOD DIV COLON ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB MUL MOD DIV COLON ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB MUL MOD DIV COLON ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB MUL MOD DIV COLON ADD ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT int 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 254, spurious reduction of production int -> var 
##
touist_simple: LET VAR AFFECT VAR RANGE 
##
## Ends in an error in state: 387.
##
## let_affect(int,formula_simple) -> LET var AFFECT int . COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## num_operations_others(int) -> int . MOD int [ SUB MUL MOD DIV COLON ADD ]
## num_operations_standard(int) -> int . ADD int [ SUB MUL MOD DIV COLON ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB MUL MOD DIV COLON ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB MUL MOD DIV COLON ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB MUL MOD DIV COLON ADD ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT int 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 254, spurious reduction of production int -> var 
##

Ill-formed 'let' statement. At this point, expected either ':' or a continuation
of the integer expression started with:
    $1
using one of the following operators:
    +, -, *, /, mod
Instead, the following statement were read:
    $0

touist_smt: LET VAR AFFECT VAR XOR 
##
## Ends in an error in state: 431.
##
## let_affect(prop,formula_smt) -> LET var AFFECT prop . COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT prop 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 254, spurious reduction of production prop -> var 
##
touist_simple: LET VAR AFFECT VAR XOR 
##
## Ends in an error in state: 317.
##
## let_affect(prop,formula_simple) -> LET var AFFECT prop . COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT prop 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 254, spurious reduction of production prop -> var 
##

Ill-formed 'let' statement. At this point, expected ':'.
Instead, the following statement were read:
    $0

touist_smt: LET VAR AFFECT XOR 
##
## Ends in an error in state: 430.
##
## let_affect(float,formula_smt) -> LET var AFFECT . float COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## let_affect(int,formula_smt) -> LET var AFFECT . int COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## let_affect(prop,formula_smt) -> LET var AFFECT . prop COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT 
##

Ill-formed 'let' statement. After $1, a float, int or proposition
is expected.
Instead, the following statement were read:
    $0

touist_simple: LET VAR AFFECT XOR 
##
## Ends in an error in state: 316.
##
## let_affect(float,formula_simple) -> LET var AFFECT . float COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## let_affect(int,formula_simple) -> LET var AFFECT . int COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## let_affect(prop,formula_simple) -> LET var AFFECT . prop COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## LET var AFFECT 
##

Ill-formed 'let' statement. After $1, a float, int or proposition
is expected.
Instead, the following statement were read:
    $0

touist_smt: LET VAR XOR 
##
## Ends in an error in state: 429.
##
## let_affect(float,formula_smt) -> LET var . AFFECT float COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## let_affect(int,formula_smt) -> LET var . AFFECT int COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## let_affect(prop,formula_smt) -> LET var . AFFECT prop COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LET var 
##
touist_simple: LET VAR XOR 
##
## Ends in an error in state: 315.
##
## let_affect(float,formula_simple) -> LET var . AFFECT float COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## let_affect(int,formula_simple) -> LET var . AFFECT int COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## let_affect(prop,formula_simple) -> LET var . AFFECT prop COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## LET var 
##

Ill-formed 'let' statement. A '=' is expected after the variable:
    $1
Instead, the following statement were read:
    $0

touist_smt: LET XOR 
##
## Ends in an error in state: 428.
##
## let_affect(float,formula_smt) -> LET . var AFFECT float COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## let_affect(int,formula_smt) -> LET . var AFFECT int COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## let_affect(prop,formula_smt) -> LET . var AFFECT prop COLON formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LET 
##
touist_simple: LET XOR 
##
## Ends in an error in state: 314.
##
## let_affect(float,formula_simple) -> LET . var AFFECT float COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## let_affect(int,formula_simple) -> LET . var AFFECT int COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## let_affect(prop,formula_simple) -> LET . var AFFECT prop COLON formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## LET 
##

Ill-formed 'let' statement. A variable expected at this point.
Instead, the following statement were read:
    $0

touist_smt: LPAREN FLOAT XOR 
##
## Ends in an error in state: 519.
##
## in_parenthesis(float) -> LPAREN float . RPAREN [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
## num -> float . [ NOTEQUAL LT LE GT GE EQUAL ]
## num_operations_others(float) -> float . MOD float [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL DIV ADD ]
## num_operations_standard(float) -> float . ADD float [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL DIV ADD ]
## num_operations_standard(float) -> float . SUB float [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL DIV ADD ]
## num_operations_standard(float) -> float . MUL float [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL DIV ADD ]
## num_operations_standard(float) -> float . DIV float [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL DIV ADD ]
##
## The known suffix of the stack is as follows:
## LPAREN float 
##
touist_simple: TUPLE LPAREN FLOAT XOR 
##
## Ends in an error in state: 277.
##
## in_parenthesis(float) -> LPAREN float . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_others(float) -> float . MOD float [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_standard(float) -> float . ADD float [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_standard(float) -> float . SUB float [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_standard(float) -> float . MUL float [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_standard(float) -> float . DIV float [ SUB RPAREN MUL MOD DIV ADD ]
##
## The known suffix of the stack is as follows:
## LPAREN float 
##

Ill-formed parenthesis: at this point, expected either ')' or
a continuation of the float expression that was started with
    $1
with one of the following operators:
    +, -, *, /, mod
Instead, the following statement were read:
    $0

touist_smt: LPAREN VAR RANGE 
##
## Ends in an error in state: 516.
##
## in_parenthesis(int) -> LPAREN int . RPAREN [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
## num -> int . [ NOTEQUAL LT LE GT GE EQUAL ]
## num_operations_others(int) -> int . MOD int [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL DIV ADD ]
## num_operations_standard(int) -> int . ADD int [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL DIV ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL DIV ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL DIV ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL DIV ADD ]
##
## The known suffix of the stack is as follows:
## LPAREN int 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 254, spurious reduction of production int -> var 
##
touist_simple: TUPLE LPAREN VAR XOR 
##
## Ends in an error in state: 239.
##
## in_parenthesis(int) -> LPAREN int . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_others(int) -> int . MOD int [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_standard(int) -> int . ADD int [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB RPAREN MUL MOD DIV ADD ]
##
## The known suffix of the stack is as follows:
## LPAREN int 
##

Ill-formed parenthesis: at this point, expected either ')' or
a continuation of the integer expression that was started with
    $1
with one of the following operators:
    +, -, *, /, mod
Instead, the following statement were read:
    $0

touist_smt: LPAREN VAR VARTUPLE 
##
## Ends in an error in state: 517.
##
## connectors(formula_smt) -> formula_smt . AND formula_smt [ XOR RPAREN OR IMPLIES EQUIV AND ]
## connectors(formula_smt) -> formula_smt . OR formula_smt [ XOR RPAREN OR IMPLIES EQUIV AND ]
## connectors(formula_smt) -> formula_smt . XOR formula_smt [ XOR RPAREN OR IMPLIES EQUIV AND ]
## connectors(formula_smt) -> formula_smt . IMPLIES formula_smt [ XOR RPAREN OR IMPLIES EQUIV AND ]
## connectors(formula_smt) -> formula_smt . EQUIV formula_smt [ XOR RPAREN OR IMPLIES EQUIV AND ]
## in_parenthesis(formula_smt) -> LPAREN formula_smt . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LPAREN formula_smt 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 254, spurious reduction of production prop -> var 
## In state 464, spurious reduction of production formula(formula_smt) -> prop 
## In state 475, spurious reduction of production formula_smt -> formula(formula_smt) 
##
touist_simple: LPAREN VAR WHEN 
##
## Ends in an error in state: 393.
##
## connectors(formula_simple) -> formula_simple . AND formula_simple [ XOR RPAREN OR IMPLIES EQUIV AND ]
## connectors(formula_simple) -> formula_simple . OR formula_simple [ XOR RPAREN OR IMPLIES EQUIV AND ]
## connectors(formula_simple) -> formula_simple . XOR formula_simple [ XOR RPAREN OR IMPLIES EQUIV AND ]
## connectors(formula_simple) -> formula_simple . IMPLIES formula_simple [ XOR RPAREN OR IMPLIES EQUIV AND ]
## connectors(formula_simple) -> formula_simple . EQUIV formula_simple [ XOR RPAREN OR IMPLIES EQUIV AND ]
## in_parenthesis(formula_simple) -> LPAREN formula_simple . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## LPAREN formula_simple 
##

Ill-formed formula: at this point, expected either ')' or
a continuation of the formula started with
    $1
using one of the following operators:
    and, or, xor, =>, <=>.
Instead, the following statement were read:
    $0

touist_simple: IF LPAREN FLOAT XOR 
##
## Ends in an error in state: 269.
##
## equality(float) -> float . EQUAL float [ XOR RPAREN OR IMPLIES EQUIV AND ]
## equality(float) -> float . NOTEQUAL float [ XOR RPAREN OR IMPLIES EQUIV AND ]
## in_operator -> float . IN set_float [ XOR RPAREN OR IMPLIES EQUIV AND ]
## in_parenthesis(float) -> LPAREN float . RPAREN [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF ELSE DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## num_operations_others(float) -> float . MOD float [ SUB RPAREN NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## num_operations_standard(float) -> float . ADD float [ SUB RPAREN NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## num_operations_standard(float) -> float . SUB float [ SUB RPAREN NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## num_operations_standard(float) -> float . MUL float [ SUB RPAREN NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## num_operations_standard(float) -> float . DIV float [ SUB RPAREN NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## order(float) -> float . LT float [ XOR RPAREN OR IMPLIES EQUIV AND ]
## order(float) -> float . LE float [ XOR RPAREN OR IMPLIES EQUIV AND ]
## order(float) -> float . GT float [ XOR RPAREN OR IMPLIES EQUIV AND ]
## order(float) -> float . GE float [ XOR RPAREN OR IMPLIES EQUIV AND ]
##
## The known suffix of the stack is as follows:
## LPAREN float 
##

Ill-formed parenthesis: at this point, expected either ')' or
a continuation of the float expression that was started with
    $1
with one of the following operators:
    +, -, *, /, mod, <=, <, >, >=, !=, ==, in
Instead, the following statement were read:
    $0

touist_simple: IF LPAREN VAR ELSE 
##
## Ends in an error in state: 268.
##
## equality(int) -> int . EQUAL int [ XOR RPAREN OR IMPLIES EQUIV AND ]
## equality(int) -> int . NOTEQUAL int [ XOR RPAREN OR IMPLIES EQUIV AND ]
## in_operator -> int . IN set_int [ XOR RPAREN OR IMPLIES EQUIV AND ]
## in_parenthesis(int) -> LPAREN int . RPAREN [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF ELSE DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## num_operations_others(int) -> int . MOD int [ SUB RPAREN NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## num_operations_standard(int) -> int . ADD int [ SUB RPAREN NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB RPAREN NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB RPAREN NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB RPAREN NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## order(int) -> int . LT int [ XOR RPAREN OR IMPLIES EQUIV AND ]
## order(int) -> int . LE int [ XOR RPAREN OR IMPLIES EQUIV AND ]
## order(int) -> int . GT int [ XOR RPAREN OR IMPLIES EQUIV AND ]
## order(int) -> int . GE int [ XOR RPAREN OR IMPLIES EQUIV AND ]
##
## The known suffix of the stack is as follows:
## LPAREN int 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production int -> var 
##

Ill-formed parenthesis: at this point, expected either ')' or
a continuation of the integer expression that was started with
    $1
with one of the following operators:
    +, -, *, /, mod, <=, <, >, >=, !=, ==, in
Instead, the following statement were read:
    $0

touist_simple: IF LPAREN VAR VARTUPLE 
##
## Ends in an error in state: 271.
##
## connectors(bool) -> bool . AND bool [ XOR RPAREN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . OR bool [ XOR RPAREN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . XOR bool [ XOR RPAREN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . IMPLIES bool [ XOR RPAREN OR IMPLIES EQUIV AND ]
## connectors(bool) -> bool . EQUIV bool [ XOR RPAREN OR IMPLIES EQUIV AND ]
## in_parenthesis(bool) -> LPAREN bool . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## LPAREN bool 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production bool -> var 
##

Ill-formed parenthesis: at this point, expected either ')' or
a continuation of the boolean expression that was started with
    $1
with one of the following operators:
    and, or, xor, =>, <=>.
Instead, the following statement were read:
    $0

touist_smt: LPAREN XOR 
##
## Ends in an error in state: 427.
##
## in_parenthesis(float) -> LPAREN . float RPAREN [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
## in_parenthesis(formula_smt) -> LPAREN . formula_smt RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## in_parenthesis(int) -> LPAREN . int RPAREN [ SUB RPAREN NOTEQUAL MUL MOD LT LE GT GE EQUAL ELSE DIV ADD ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

Ill-formed parenthesis: at this point, expected one of the following:
    - a formula,
    - an integer or float expression.
Instead, the following statement were read:
    $0

touist_smt: SQRT LPAREN XOR 
##
## Ends in an error in state: 9.
##
## in_parenthesis(float) -> LPAREN . float RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

Ill-formed parenthesis: at this point, expected a float expression.
Instead, the following statement were read:
    $0

touist_simple: EXACT LPAREN XOR 
##
## Ends in an error in state: 38.
##
## in_parenthesis(int) -> LPAREN . int RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

Ill-formed parenthesis: at this point, expected a integer expression.
Instead, the following statement were read:
    $0

touist_simple: IF LPAREN XOR 
##
## Ends in an error in state: 19.
##
## in_parenthesis(bool) -> LPAREN . bool RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## in_parenthesis(float) -> LPAREN . float RPAREN [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF ELSE DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## in_parenthesis(int) -> LPAREN . int RPAREN [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF ELSE DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

Ill-formed parenthesis: at this point, expected an integer, float or
boolean expression.
Instead, the following statement were read:
    $0

touist_simple: LPAREN XOR 
##
## Ends in an error in state: 313.
##
## in_parenthesis(formula_simple) -> LPAREN . formula_simple RPAREN [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

Ill-formed parenthesis: at this point, expected a formula.
Instead, the following statement were read:
    $0

touist_simple: TUPLE LPAREN XOR 
##
## Ends in an error in state: 15.
##
## in_parenthesis(float) -> LPAREN . float RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## in_parenthesis(int) -> LPAREN . int RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## LPAREN 
##

Ill-formed parenthesis: at this point, expected a float expression.
Instead, the following statement were read:
    $0

touist_smt: NOT XOR 
##
## Ends in an error in state: 426.
##
## connectors(formula_smt) -> NOT . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## NOT 
##
touist_simple: NOT XOR 
##
## Ends in an error in state: 312.
##
## connectors(formula_simple) -> NOT . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## NOT 
##

Ill-formed $1 operator. At this point, expected a formula.
Instead, the following statement were read:
    $0

touist_simple: IF NOT XOR 
##
## Ends in an error in state: 18.
##
## connectors(bool) -> NOT . bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## NOT 
##

Ill-formed $1 operator. At this point, expected a boolean.
Instead, the following statement were read:
    $0

touist_smt: SQRT SUB XOR 
##
## Ends in an error in state: 8.
##
## num_operations_standard(float) -> SUB . float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## SUB 
##
touist_smt: SUB XOR 
##
## Ends in an error in state: 6.
##
## num_operations_standard(float) -> SUB . float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> SUB . int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## SUB 
##
touist_simple: EXACT SUB XOR 
##
## Ends in an error in state: 37.
##
## num_operations_standard(int) -> SUB . int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## SUB 
##

Ill-formed $1 operator. At this point, expected a number.
Instead, the following statement were read:
    $0

touist_smt: SQRT VAR XOR 
##
## Ends in an error in state: 293.
##
## float -> SQRT float . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_others(float) -> float . MOD float [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_standard(float) -> float . ADD float [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_standard(float) -> float . SUB float [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_standard(float) -> float . MUL float [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_standard(float) -> float . DIV float [ SUB RPAREN MUL MOD DIV ADD ]
##
## The known suffix of the stack is as follows:
## SQRT float 
##
touist_smt: ABS FLOAT XOR 
##
## Ends in an error in state: 100.
##
## num_operations_others(float) -> float . MOD float [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_others(float) -> ABS float . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . ADD float [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_standard(float) -> float . SUB float [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_standard(float) -> float . MUL float [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_standard(float) -> float . DIV float [ SUB RPAREN MUL MOD DIV ADD ]
##
## The known suffix of the stack is as follows:
## ABS float 
##

Ill-formed $2. At this point, expected either ')' or a continuation of the
float expression that was started with
    $1
using one of the following operators:
    +, -, *, /, mod.
Instead, the following statement were read:
    $0

touist_smt: SUB FLOAT WHEN 
##
## Ends in an error in state: 292.
##
## num_operations_others(float) -> float . MOD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . ADD float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . SUB float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> SUB float . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . MUL float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(float) -> float . DIV float [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## SUB float 
##

Ill-formed $2 operator. Note that in this context, $2 means the
negation (as in '-1') and not the substraction (as in '1-2').
At this point, expected a continuation of the float expression
that was started with
    $1
using one of the following operators:
    +, -, *, /, mod.
Instead, the following statement were read:
    $0

touist_smt: SUB VAR WHEN 
##
## Ends in an error in state: 241.
##
## num_operations_others(int) -> int . MOD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . ADD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . SUB int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> SUB int . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . MUL int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . DIV int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## SUB int 
##

Ill-formed $2 operator. Note that in this context, $2 means the
negation (as in '-1') and not the substraction (as in '1-2').
At this point, expected a continuation of the integer expression
that was started with
    $1
using one of the following operators:
    +, -, *, /, mod
Instead, the following statement were read:
    $0

touist_smt: TERM WHEN 
##
## Ends in an error in state: 464.
##
## any_atom -> prop . [ NOTEQUAL LT LE GT GE EQUAL ]
## formula(formula_smt) -> prop . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## prop 
##

Ill-formed proposition as part of a formula. Nothing is expected after the
proposition
    $1
Instead, the following statement were read:
    $0

touist_simple: IF TERM XOR 
##
## Ends in an error in state: 42.
##
## equality(prop) -> prop . EQUAL prop [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## equality(prop) -> prop . NOTEQUAL prop [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## in_operator -> prop . IN set_prop [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## prop 
##
touist_simple: VAR AFFECT TERM XOR 
##
## Ends in an error in state: 402.
##
## any_atom -> prop . [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## equality(prop) -> prop . EQUAL prop [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## equality(prop) -> prop . NOTEQUAL prop [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## in_operator -> prop . IN set_prop [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## prop 
##

Ill-formed expression of propositions. At this point, a continuation
of the expression of propositions is expected using one of the following
operators:
    ==, !=, in
Instead, the following statement were read:
    $0

touist_smt: TOFLOAT VAR XOR 
##
## Ends in an error in state: 295.
##
## float -> TOFLOAT num . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## TOFLOAT num 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 297, spurious reduction of production num -> int 
##
touist_smt: TOINT VAR XOR 
##
## Ends in an error in state: 299.
##
## int -> TOINT num . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## TOINT num 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 297, spurious reduction of production num -> int 
##

Ill-formed $2. At this point, expected either ')' or a continuation of the
float or integer expression that was started with:
    $1
using one of the following operators:
    +, -, *, /, mod.
Instead, the following statement were read:
    $0

touist_smt: ABS VAR XOR 
##
## Ends in an error in state: 35.
##
## num_operations_others(int) -> int . MOD int [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_others(int) -> ABS int . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . ADD int [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB RPAREN MUL MOD DIV ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB RPAREN MUL MOD DIV ADD ]
##
## The known suffix of the stack is as follows:
## ABS int 
##

Ill-formed $2. At this point, expected either ')' or
a continuation of the integer expression that was started with
    $1
with one of the following operators:
    +, -, *, /, mod
Instead, the following statement were read:
    $0

touist_smt: VAR AND TOP WHEN 
##
## Ends in an error in state: 495.
##
## connectors(formula_smt) -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt AND formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## formula_smt AND formula_smt 
##
touist_smt: VAR EQUIV TOP WHEN 
##
## Ends in an error in state: 499.
##
## connectors(formula_smt) -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt EQUIV formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## formula_smt EQUIV formula_smt 
##
touist_smt: VAR IMPLIES TOP WHEN 
##
## Ends in an error in state: 497.
##
## connectors(formula_smt) -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt IMPLIES formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## formula_smt IMPLIES formula_smt 
##
touist_smt: VAR OR TOP WHEN 
##
## Ends in an error in state: 493.
##
## connectors(formula_smt) -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt OR formula_smt . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## formula_smt OR formula_smt 
##
touist_simple: VAR AND VAR WHEN 
##
## Ends in an error in state: 371.
##
## connectors(formula_simple) -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple AND formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## formula_simple AND formula_simple 
##
touist_simple: VAR EQUIV VAR WHEN 
##
## Ends in an error in state: 375.
##
## connectors(formula_simple) -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple EQUIV formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## formula_simple EQUIV formula_simple 
##
touist_simple: VAR IMPLIES VAR WHEN 
##
## Ends in an error in state: 373.
##
## connectors(formula_simple) -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple IMPLIES formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## formula_simple IMPLIES formula_simple 
##
touist_simple: VAR OR VAR WHEN 
##
## Ends in an error in state: 369.
##
## connectors(formula_simple) -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple OR formula_simple . [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## formula_simple OR formula_simple 
##

Ill-formed formula. At this point, a continuation of the formula
    $1
is expected using one of the following operators:
    and, or, xor, =>, <=>
Instead, the following statement were read:
    $0
    
touist_smt: TOP WHEN 
##
## Ends in an error in state: 526.
##
## connectors(formula_smt) -> formula_smt . AND formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . OR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . XOR formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . IMPLIES formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(formula_smt) -> formula_smt . EQUIV formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## nonempty_list(formula_smt) -> formula_smt . [ EOF DATA ]
## nonempty_list(formula_smt) -> formula_smt . nonempty_list(formula_smt) [ EOF DATA ]
##
## The known suffix of the stack is as follows:
## formula_smt 
##
touist_simple: TOP WHEN 
##
## Ends in an error in state: 414.
##
## connectors(formula_simple) -> formula_simple . AND formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . OR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . XOR formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . IMPLIES formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## connectors(formula_simple) -> formula_simple . EQUIV formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
## nonempty_list(formula_simple) -> formula_simple . [ EOF DATA ]
## nonempty_list(formula_simple) -> formula_simple . nonempty_list(formula_simple) [ EOF DATA ]
##
## The known suffix of the stack is as follows:
## formula_simple 
##

Ill-formed formula. At this point, a continuation of the formula
    $1
is expected using one of the following operators:
    and, or, xor, =>, <=>
or you can begin a new formula with a whitespace.
Instead, the following statement were read:
    $0

touist_smt: VAR AND XOR 
##
## Ends in an error in state: 494.
##
## connectors(formula_smt) -> formula_smt AND . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## formula_smt AND 
##
touist_smt: VAR EQUIV XOR 
##
## Ends in an error in state: 498.
##
## connectors(formula_smt) -> formula_smt EQUIV . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## formula_smt EQUIV 
##
touist_smt: VAR IMPLIES XOR 
##
## Ends in an error in state: 496.
##
## connectors(formula_smt) -> formula_smt IMPLIES . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## formula_smt IMPLIES 
##
touist_smt: VAR OR XOR 
##
## Ends in an error in state: 492.
##
## connectors(formula_smt) -> formula_smt OR . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## formula_smt OR 
##
touist_smt: VAR XOR XOR 
##
## Ends in an error in state: 473.
##
## connectors(formula_smt) -> formula_smt XOR . formula_smt [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## formula_smt XOR 
##
touist_simple: VAR AND XOR 
##
## Ends in an error in state: 370.
##
## connectors(formula_simple) -> formula_simple AND . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## formula_simple AND 
##
touist_simple: VAR EQUIV XOR 
##
## Ends in an error in state: 374.
##
## connectors(formula_simple) -> formula_simple EQUIV . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## formula_simple EQUIV 
##
touist_simple: VAR IMPLIES XOR 
##
## Ends in an error in state: 372.
##
## connectors(formula_simple) -> formula_simple IMPLIES . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## formula_simple IMPLIES 
##
touist_simple: VAR OR XOR 
##
## Ends in an error in state: 368.
##
## connectors(formula_simple) -> formula_simple OR . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## formula_simple OR 
##
touist_simple: VAR XOR XOR 
##
## Ends in an error in state: 364.
##
## connectors(formula_simple) -> formula_simple XOR . formula_simple [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## formula_simple XOR 
##

Ill-formed $1 operator. At this point, a formula is expected.
Instead, the following statement were read:
    $0

touist_smt: VAR EQUAL XOR 
##
## Ends in an error in state: 490.
##
## equality(any_atom) -> any_atom EQUAL . any_atom [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## any_atom EQUAL 
##
touist_smt: VAR GE XOR 
##
## Ends in an error in state: 488.
##
## order(any_atom) -> any_atom GE . any_atom [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## any_atom GE 
##
touist_smt: VAR GT XOR 
##
## Ends in an error in state: 486.
##
## order(any_atom) -> any_atom GT . any_atom [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## any_atom GT 
##
touist_smt: VAR LE XOR 
##
## Ends in an error in state: 484.
##
## order(any_atom) -> any_atom LE . any_atom [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## any_atom LE 
##
touist_smt: VAR LT XOR 
##
## Ends in an error in state: 482.
##
## order(any_atom) -> any_atom LT . any_atom [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## any_atom LT 
##
touist_smt: VAR NOTEQUAL XOR 
##
## Ends in an error in state: 479.
##
## equality(any_atom) -> any_atom NOTEQUAL . any_atom [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## any_atom NOTEQUAL 
##

Ill-formed $1 operator. At this point, an integer, float or proposition
is expected.
Instead, the following statement were read:
    $0

touist_simple: IF VAR RPAREN 
##
## Ends in an error in state: 58.
##
## equality(int) -> int . EQUAL int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## equality(int) -> int . NOTEQUAL int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## in_operator -> int . IN set_int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## num_operations_others(int) -> int . MOD int [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## num_operations_standard(int) -> int . ADD int [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB NOTEQUAL MUL MOD LT LE IN GT GE EQUAL DIV ADD ]
## order(int) -> int . LT int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## order(int) -> int . LE int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## order(int) -> int . GT int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## order(int) -> int . GE int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## int 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production int -> var 
##
touist_simple: VAR AFFECT VAR ELSE 
##
## Ends in an error in state: 404.
##
## equality(int) -> int . EQUAL int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## equality(int) -> int . NOTEQUAL int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## in_operator -> int . IN set_int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## num -> int . [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## num_operations_others(int) -> int . MOD int [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## num_operations_standard(int) -> int . ADD int [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## num_operations_standard(int) -> int . SUB int [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## num_operations_standard(int) -> int . MUL int [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## num_operations_standard(int) -> int . DIV int [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## order(int) -> int . LT int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## order(int) -> int . LE int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## order(int) -> int . GT int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## order(int) -> int . GE int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## int 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 401, spurious reduction of production int -> var 
##

Ill-formed integer expression: at this point, expected a continuation of
the integer expression started with
    $1
using one of the following operators:
   +, -, *, /, mod, <, <=, >, >=, in, ==, !=
Instead, the following statement were read:
    $0

touist_simple: TUPLE VAR RANGE 
##
## Ends in an error in state: 302.
##
## indices -> int . [ RPAREN COMMA ]
## num_operations_others(int) -> int . MOD int [ SUB RPAREN MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . ADD int [ SUB RPAREN MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB RPAREN MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB RPAREN MUL MOD DIV COMMA ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB RPAREN MUL MOD DIV COMMA ADD ]
##
## The known suffix of the stack is as follows:
## int 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 254, spurious reduction of production int -> var 
##
touist_smt: INT WHEN 
##
## Ends in an error in state: 297.
##
## num -> int . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOTEQUAL NOT LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## num_operations_others(int) -> int . MOD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . ADD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . SUB int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . MUL int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . DIV int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## int 
##

Ill-formed integer expression: at this point, expected a continuation of
the integer expression started with
    $1
using one of the following operators:
    +, -, *, /, mod
Instead, the following statement were read:
    $0

# Ill-formed formula: at this point, expected a continuation of
# the formula started with
#     $1
# using one of the following operators:
#     and, or, xor, =>, <=>.
# Instead, the following statement were read:
#     $0
touist_smt: VAR RANGE 
##
## Ends in an error in state: 521.
##
## float -> var . [ SUB NOTEQUAL MUL MOD LT LE GT GE EQUAL DIV ADD ]
## global_affect -> var . AFFECT global_affect_types [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## int -> var . [ SUB NOTEQUAL MUL MOD LT LE GT GE EQUAL DIV ADD ]
## prop -> var . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOTEQUAL NOT LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## var 
##
touist_simple: VAR WHEN 
##
## Ends in an error in state: 396.
##
## global_affect -> var . AFFECT global_affect_types [ VARTUPLE VAR TUPLE TOP TERM NOT LPAREN LET IF EXACT BOTTOM BIGOR BIGAND ATMOST ATLEAST ]
## prop -> var . [ XOR VARTUPLE VAR TUPLE TOP TERM OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## var 
##
touist_simple: VAR DATA VAR XOR 
##
## Ends in an error in state: 419.
##
## global_affect -> var . AFFECT global_affect_types [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
##
## The known suffix of the stack is as follows:
## var 
##

Ill-formed global affectation. At this point, '=' is expected.
Instead, the following statement were read:
    $0
NOTE: this error message can be wrong because I do not know
how we get to this error.

touist_simple: IF VAR WHEN 
##
## Ends in an error in state: 40.
##
## bool -> var . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## float -> var . [ SUB RPAREN NOTEQUAL MUL MOD LT LE IN GT GE EQUAL ELSE DIV ADD ]
## int -> var . [ SUB RPAREN NOTEQUAL MUL MOD LT LE IN GT GE EQUAL ELSE DIV ADD ]
## prop -> var . [ NOTEQUAL IN EQUAL ]
##
## The known suffix of the stack is as follows:
## var 
##
touist_smt: VAR VAR WHEN 
##
## Ends in an error in state: 254.
##
## float -> var . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## int -> var . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## prop -> var . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN RBRACK OR NOTEQUAL NOT LT LPAREN LET LE INT IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## var 
##
touist_simple: VAR AFFECT VAR WHEN 
##
## Ends in an error in state: 401.
##
## bool -> var . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF ELSE CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## float -> var . [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF ELSE DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## int -> var . [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IF GT GE FLOAT EXACT EQUAL EOF ELSE DIV CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ADD ABS ]
## prop -> var . [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOTEQUAL NOT LPAREN LET INT IN IF FLOAT EXACT EQUAL EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## set_float -> var . [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## set_int -> var . [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## set_prop -> var . [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
##
## The known suffix of the stack is as follows:
## var 
##

Ill-formed variable:
    $1
I cannot give any suggestions because I do not know how we
get to this error.

touist_simple: BIGOR VAR IN VAR WHEN VAR VARTUPLE 
##
## Ends in an error in state: 336.
##
## connectors(bool) -> bool . AND bool [ XOR OR IMPLIES EQUIV COLON AND ]
## connectors(bool) -> bool . OR bool [ XOR OR IMPLIES EQUIV COLON AND ]
## connectors(bool) -> bool . XOR bool [ XOR OR IMPLIES EQUIV COLON AND ]
## connectors(bool) -> bool . IMPLIES bool [ XOR OR IMPLIES EQUIV COLON AND ]
## connectors(bool) -> bool . EQUIV bool [ XOR OR IMPLIES EQUIV COLON AND ]
## when_cond -> WHEN bool . [ COLON ]
##
## The known suffix of the stack is as follows:
## WHEN bool 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production bool -> var 
##

Ill-formed 'when' condition. At this point, expected either ':' or a continuation
of the boolean expression that was started with
    $1
using one of the following operators:
    and, or, xor, =>, <=>.
Instead, the following statement were read:
    $0

touist_simple: BIGOR VAR IN VAR WHEN XOR 
##
## Ends in an error in state: 335.
##
## when_cond -> WHEN . bool [ COLON ]
##
## The known suffix of the stack is as follows:
## WHEN 
##

Ill-formed 'when' condition. At this point, a boolean expression
is expected.
Instead, the following statement were read:
    $0

# Ill-formed boolean expression: at this point, expecting a
# continuation of the boolean expression started with
#     $1
# using one of the following operators:
#     and, or, xor, =>, <=>.
# or finish the affectation with a new variable affectation.
# Instead, the following statement were read:
#     $0
#
touist_simple: VAR AFFECT LBRACK RBRACK XOR 
##
## Ends in an error in state: 422.
##
## nonempty_list(global_affect) -> global_affect . [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## nonempty_list(global_affect) -> global_affect . nonempty_list(global_affect) [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
##
## The known suffix of the stack is as follows:
## global_affect 
##

Ill-formed global affectation. At this point, a global affectation
should be read.
Instead, the following statement were read:
    $0

touist_simple: VAR AFFECT XOR 
##
## Ends in an error in state: 397.
##
## global_affect -> var AFFECT . global_affect_types [ VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT NOT LPAREN LET INT IF FLOAT EXACT EOF CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
##
## The known suffix of the stack is as follows:
## var AFFECT 
##

Ill-formed affectation. After '=', one of the following types is expected:
- integer, float or boolean expressions,
- a proposition,
- a set of integers, of floats or propositions
Instead, the following statement were read:
    $0

touist_simple: VAR AFFECT BOOL TOINT 
##
## Ends in an error in state: 411.
##
## touist_simple -> nonempty_list(global_affect) . nonempty_list(formula_simple) EOF [ # ]
##
## The known suffix of the stack is as follows:
## nonempty_list(global_affect) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 407, spurious reduction of production global_affect_types -> bool 
## In state 405, spurious reduction of production global_affect -> var AFFECT global_affect_types 
## In state 422, spurious reduction of production nonempty_list(global_affect) -> global_affect 
##
touist_smt: VAR AFFECT BOOL EOF 
##
## Ends in an error in state: 523.
##
## touist_smt -> nonempty_list(global_affect) . nonempty_list(formula_smt) EOF [ # ]
##
## The known suffix of the stack is as follows:
## nonempty_list(global_affect) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 407, spurious reduction of production global_affect_types -> bool 
## In state 405, spurious reduction of production global_affect -> var AFFECT global_affect_types 
## In state 422, spurious reduction of production nonempty_list(global_affect) -> global_affect 
##

If you are done with affectations, then a formula is expected.
NOTE: Affectations can be either
- before formulas (no separator is required),
- or after the formulas (in this cas, 'data' separates formulas
  from affectations)

touist_simple: VAR DATA VAR AFFECT BOOL TUPLE 
##
## Ends in an error in state: 420.
##
## touist_simple -> nonempty_list(formula_simple) DATA nonempty_list(global_affect) . EOF [ # ]
##
## The known suffix of the stack is as follows:
## nonempty_list(formula_simple) DATA nonempty_list(global_affect) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 407, spurious reduction of production global_affect_types -> bool 
## In state 405, spurious reduction of production global_affect -> var AFFECT global_affect_types 
## In state 422, spurious reduction of production nonempty_list(global_affect) -> global_affect 
##
touist_smt: VAR DATA VAR AFFECT BOOL TUPLE 
##
## Ends in an error in state: 531.
##
## touist_smt -> nonempty_list(formula_smt) DATA nonempty_list(global_affect) . EOF [ # ]
##
## The known suffix of the stack is as follows:
## nonempty_list(formula_smt) DATA nonempty_list(global_affect) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 407, spurious reduction of production global_affect_types -> bool 
## In state 405, spurious reduction of production global_affect -> var AFFECT global_affect_types 
## In state 422, spurious reduction of production nonempty_list(global_affect) -> global_affect 
##

Ill-formed affectations. When affectations are given after formulas,
no formula must be given after affectations.
NOTE: Affectations can be either
- before formulas (no separator is required),
- or after the formulas (in this cas, 'data' separates formulas
  from affectations)

touist_simple: VAR AFFECT BOOL TOP DATA 
##
## Ends in an error in state: 412.
##
## touist_simple -> nonempty_list(global_affect) nonempty_list(formula_simple) . EOF [ # ]
##
## The known suffix of the stack is as follows:
## nonempty_list(global_affect) nonempty_list(formula_simple) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 414, spurious reduction of production nonempty_list(formula_simple) -> formula_simple 
##
touist_smt: VAR AFFECT BOOL BOTTOM DATA 
##
## Ends in an error in state: 524.
##
## touist_smt -> nonempty_list(global_affect) nonempty_list(formula_smt) . EOF [ # ]
##
## The known suffix of the stack is as follows:
## nonempty_list(global_affect) nonempty_list(formula_smt) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 526, spurious reduction of production nonempty_list(formula_smt) -> formula_smt 
##

Ill-formed formula: at this point, expected a new formula.
Because you already did affectations at the beginning,
you cannot do affectations anymore.
NOTE: Affectations can be either
- before formulas (no separator is required),
- or after the formulas (in this cas, 'data' separates formulas
  from affectations)
Instead, the following statement were read:
    $0

touist_simple: VAR DATA XOR 
##
## Ends in an error in state: 418.
##
## touist_simple -> nonempty_list(formula_simple) DATA . nonempty_list(global_affect) EOF [ # ]
##
## The known suffix of the stack is as follows:
## nonempty_list(formula_simple) DATA 
##
touist_smt: VAR DATA XOR 
##
## Ends in an error in state: 530.
##
## touist_smt -> nonempty_list(formula_smt) DATA . nonempty_list(global_affect) EOF [ # ]
##
## The known suffix of the stack is as follows:
## nonempty_list(formula_smt) DATA 
##

The 'data' keyword should be followed of a non-empty list of
affectations of global variables.
NOTE: Affectations can be either
- before formulas (no separator is required),
- or after the formulas (in this cas, 'data' separates formulas
 from affectations)

touist_simple: IF EMPTY VAR XOR 
##
## Ends in an error in state: 255.
##
## bool -> EMPTY any_set . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## EMPTY any_set 
##

Ill-formed $2. At this point, ')' is expected.
Instead, the following statement were read:
    $0

touist_simple: IF EMPTY XOR 
##
## Ends in an error in state: 22.
##
## bool -> EMPTY . any_set RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## EMPTY 
##
touist_smt: CARD XOR 
##
## Ends in an error in state: 25.
##
## int -> CARD . any_set RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## CARD 
##

Ill-formed $2. At this point, a set of any kind is expected.
Instead, the following statement were read:
    $0

touist_simple: IF FLOAT IN DIFF XOR 
##
## Ends in an error in state: 139.
##
## set_operation(set_float) -> DIFF . set_float COMMA set_float RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## DIFF 
##
touist_simple: IF FLOAT IN INTER XOR 
##
## Ends in an error in state: 129.
##
## set_operation(set_float) -> INTER . set_float COMMA set_float RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## INTER 
##
touist_simple: IF FLOAT IN UNION XOR 
##
## Ends in an error in state: 118.
##
## set_operation(set_float) -> UNION . set_float COMMA set_float RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## UNION 
##

Ill-formed $1. At this point, expecting a set of floats.
Instead, the following statement were read:
    $0

touist_simple: IF INT IN DIFF XOR 
##
## Ends in an error in state: 178.
##
## set_operation(set_int) -> DIFF . set_int COMMA set_int RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## DIFF 
##
touist_simple: IF INT IN INTER XOR 
##
## Ends in an error in state: 89.
##
## set_operation(set_int) -> INTER . set_int COMMA set_int RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## INTER 
##
touist_simple: IF INT IN UNION XOR 
##
## Ends in an error in state: 78.
##
## set_operation(set_int) -> UNION . set_int COMMA set_int RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## UNION 
##

Ill-formed $1. At this point, expecting a set of integers.
Instead, the following statement were read:
    $0

touist_smt: CARD INTER XOR 
##
## Ends in an error in state: 26.
##
## set_operation(set_float) -> INTER . set_float COMMA set_float RPAREN [ WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## set_operation(set_int) -> INTER . set_int COMMA set_int RPAREN [ WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
## set_operation(set_prop) -> INTER . set_prop COMMA set_prop RPAREN [ WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN NOT LPAREN LET INT IF FLOAT EXACT EOF ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST ABS ]
##
## The known suffix of the stack is as follows:
## INTER 
##
touist_simple: IF SUBSET XOR 
##
## Ends in an error in state: 12.
##
## subset_statement -> SUBSET . set_int COMMA set_int RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## subset_statement -> SUBSET . set_float COMMA set_float RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## subset_statement -> SUBSET . set_prop COMMA set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## SUBSET 
##

Ill-formed $1. At this point, expecting a set of integers, floats
or propositions.
Instead, the following statement were read:
    $0

touist_simple: IF VAR IN INTER XOR 
##
## Ends in an error in state: 54.
##
## set_operation(set_prop) -> INTER . set_prop COMMA set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## INTER 
##
touist_simple: IF VAR IN UNION XOR 
##
## Ends in an error in state: 47.
##
## set_operation(set_prop) -> UNION . set_prop COMMA set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## UNION 
##
touist_simple: IF VAR IN DIFF XOR 
##
## Ends in an error in state: 209.
##
## set_operation(set_prop) -> DIFF . set_prop COMMA set_prop RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## DIFF 
##

Ill-formed $1. At this point, expecting a set of propositions.
Instead, the following statement were read:
    $0

touist_smt: TOFLOAT XOR 
##
## Ends in an error in state: 5.
##
## float -> TOFLOAT . num RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## TOFLOAT 
##
touist_smt: TOINT XOR 
##
## Ends in an error in state: 4.
##
## int -> TOINT . num RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## TOINT 
##
touist_smt: ABS XOR 
##
## Ends in an error in state: 29.
##
## num_operations_others(float) -> ABS . float RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_others(int) -> ABS . int RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## ABS 
##

Ill-formed $1. At this point, an integer or float expression is expected.
Instead, the following statement were read:
    $0

touist_simple: EXACT ABS XOR 
##
## Ends in an error in state: 60.
##
## num_operations_others(int) -> ABS . int RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## ABS 
##

Ill-formed $1. At this point, an integer expression is expected.
Instead, the following statement were read:
    $0

touist_smt: SQRT XOR 
##
## Ends in an error in state: 7.
##
## float -> SQRT . float RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## SQRT 
##
touist_smt: SQRT ABS XOR 
##
## Ends in an error in state: 98.
##
## num_operations_others(float) -> ABS . float RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## ABS 
##

Ill-formed $1. At this point, a float expression is expected.
Instead, the following statement were read:
    $0

touist_simple: IF IF VAR THEN BOOL ELSE VAR VARTUPLE 
##
## Ends in an error in state: 266.
##
## connectors(bool) -> bool . AND bool [ XOR OR IMPLIES EQUIV END AND ]
## connectors(bool) -> bool . OR bool [ XOR OR IMPLIES EQUIV END AND ]
## connectors(bool) -> bool . XOR bool [ XOR OR IMPLIES EQUIV END AND ]
## connectors(bool) -> bool . IMPLIES bool [ XOR OR IMPLIES EQUIV END AND ]
## connectors(bool) -> bool . EQUIV bool [ XOR OR IMPLIES EQUIV END AND ]
## if_statement(bool) -> IF bool THEN bool ELSE bool . END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN bool ELSE bool 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production bool -> var 
##
touist_smt: IF VAR THEN FLOAT ELSE VAR XOR 
##
## Ends in an error in state: 262.
##
## if_statement(float) -> IF bool THEN float ELSE float . END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_others(float) -> float . MOD float [ SUB MUL MOD END DIV ADD ]
## num_operations_standard(float) -> float . ADD float [ SUB MUL MOD END DIV ADD ]
## num_operations_standard(float) -> float . SUB float [ SUB MUL MOD END DIV ADD ]
## num_operations_standard(float) -> float . MUL float [ SUB MUL MOD END DIV ADD ]
## num_operations_standard(float) -> float . DIV float [ SUB MUL MOD END DIV ADD ]
##
## The known suffix of the stack is as follows:
## IF bool THEN float ELSE float 
##

Ill-formed 'if'. In the 'else' expression, expected a continuation
of the float expression that was started with
    $1
This type is required because of the 'then' expression that was a float:
    $3
You can continue it using one of the following operators:
    +, -, *, /, mod
Instead, the following statement were read:
    $0

touist_smt: IF VAR THEN INT ELSE VAR XOR 
##
## Ends in an error in state: 237.
##
## if_statement(int) -> IF bool THEN int ELSE int . END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_others(int) -> int . MOD int [ SUB MUL MOD END DIV ADD ]
## num_operations_standard(int) -> int . ADD int [ SUB MUL MOD END DIV ADD ]
## num_operations_standard(int) -> int . SUB int [ SUB MUL MOD END DIV ADD ]
## num_operations_standard(int) -> int . MUL int [ SUB MUL MOD END DIV ADD ]
## num_operations_standard(int) -> int . DIV int [ SUB MUL MOD END DIV ADD ]
##
## The known suffix of the stack is as follows:
## IF bool THEN int ELSE int 
##

Ill-formed 'if'. In the 'else' expression, expected a continuation
of the integer expression that was started with
    $1
This type is required because of the 'then' expression that was an integer:
    $3
You can continue it using one of the following operators:
    +, -, *, /, mod
Instead, the following statement were read:
    $0

touist_simple: IF INT EQUAL VAR WHEN 
##
## Ends in an error in state: 206.
##
## equality(int) -> int EQUAL int . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## num_operations_others(int) -> int . MOD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . ADD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . SUB int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . MUL int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . DIV int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## int EQUAL int 
##
touist_simple: IF INT NOTEQUAL VAR WHEN 
##
## Ends in an error in state: 64.
##
## equality(int) -> int NOTEQUAL int . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## num_operations_others(int) -> int . MOD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . ADD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . SUB int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . MUL int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . DIV int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
##
## The known suffix of the stack is as follows:
## int NOTEQUAL int 
##
touist_simple: IF VAR GE VAR WHEN 
##
## Ends in an error in state: 204.
##
## num_operations_others(int) -> int . MOD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . ADD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . SUB int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . MUL int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . DIV int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## order(int) -> int GE int . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## int GE int 
##
touist_simple: IF VAR GT VAR WHEN 
##
## Ends in an error in state: 202.
##
## num_operations_others(int) -> int . MOD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . ADD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . SUB int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . MUL int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . DIV int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## order(int) -> int GT int . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## int GT int 
##
touist_simple: IF VAR LE VAR WHEN 
##
## Ends in an error in state: 76.
##
## num_operations_others(int) -> int . MOD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . ADD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . SUB int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . MUL int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . DIV int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## order(int) -> int LE int . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## int LE int 
##
touist_simple: IF VAR LT VAR WHEN 
##
## Ends in an error in state: 74.
##
## num_operations_others(int) -> int . MOD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . ADD int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . SUB int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . MUL int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## num_operations_standard(int) -> int . DIV int [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT MUL MOD LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DIV COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ADD ABS ]
## order(int) -> int LT int . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## int LT int 
##

Ill-formed $2 operator. At this point, expected a continuation
of the integer expression started with
    $1
To continue it, you can use one of the following operators:
    +, -, *, /, mod
Instead, the following statement were read:
    $0

touist_simple: IF VAR AND BOOL WHEN 
##
## Ends in an error in state: 156.
##
## connectors(bool) -> bool . AND bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool AND bool . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . OR bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . XOR bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . IMPLIES bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . EQUIV bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## bool AND bool 
##
touist_simple: IF VAR EQUIV BOOL WHEN 
##
## Ends in an error in state: 160.
##
## connectors(bool) -> bool . AND bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . OR bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . XOR bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . IMPLIES bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . EQUIV bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool EQUIV bool . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## bool EQUIV bool 
##
touist_simple: IF VAR IMPLIES BOOL WHEN 
##
## Ends in an error in state: 158.
##
## connectors(bool) -> bool . AND bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . OR bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . XOR bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . IMPLIES bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool IMPLIES bool . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . EQUIV bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## bool IMPLIES bool 
##
touist_simple: IF VAR OR BOOL WHEN 
##
## Ends in an error in state: 154.
##
## connectors(bool) -> bool . AND bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . OR bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool OR bool . [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . XOR bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . IMPLIES bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
## connectors(bool) -> bool . EQUIV bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## bool OR bool 
##

Ill-formed $2 operator. At this point, expected a continuation
of the boolean expression started with
    $1
To continue it, you can use one of the following operators:
    and, or, xor, =>, <=>
Instead, the following statement were read:
    $0

touist_simple: IF VAR AND XOR 
##
## Ends in an error in state: 155.
##
## connectors(bool) -> bool AND . bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## bool AND 
##
touist_simple: IF VAR EQUIV XOR 
##
## Ends in an error in state: 159.
##
## connectors(bool) -> bool EQUIV . bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## bool EQUIV 
##
touist_simple: IF VAR IMPLIES XOR 
##
## Ends in an error in state: 157.
##
## connectors(bool) -> bool IMPLIES . bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## bool IMPLIES 
##
touist_simple: IF VAR OR XOR 
##
## Ends in an error in state: 153.
##
## connectors(bool) -> bool OR . bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## bool OR 
##
touist_simple: IF VAR XOR XOR 
##
## Ends in an error in state: 136.
##
## connectors(bool) -> bool XOR . bool [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## bool XOR 
##

Ill-formed $1 operator. At this point, a boolean expression.
This type is required because the left-hand operand is a boolean:
    $2
Instead, the following statement were read:
    $0

touist_smt: CARD IF VAR THEN LBRACK INT RBRACK ELSE VAR XOR 
##
## Ends in an error in state: 190.
##
## if_statement(set_int) -> IF bool THEN set_int ELSE set_int . END [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN set_int ELSE set_int 
##
touist_smt: CARD IF VAR THEN LBRACK TERM RBRACK ELSE VAR XOR 
##
## Ends in an error in state: 220.
##
## if_statement(set_prop) -> IF bool THEN set_prop ELSE set_prop . END [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN set_prop ELSE set_prop 
##
touist_smt: CARD IF VAR THEN VAR ELSE VAR XOR 
##
## Ends in an error in state: 151.
##
## if_statement(set_float) -> IF bool THEN set_float ELSE set_float . END [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN set_float ELSE set_float 
##

Ill-formed 'if'. Expected either 'end' to finish the 'else' expression.
Instead, read the following statement:
    $0

touist_smt: IF VAR THEN VAR ELSE VAR VARTUPLE 
##
## Ends in an error in state: 506.
##
## connectors(formula_smt) -> formula_smt . AND formula_smt [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_smt) -> formula_smt . OR formula_smt [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_smt) -> formula_smt . XOR formula_smt [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_smt) -> formula_smt . IMPLIES formula_smt [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_smt) -> formula_smt . EQUIV formula_smt [ XOR OR IMPLIES EQUIV END AND ]
## if_statement(formula_smt) -> IF bool THEN formula_smt ELSE formula_smt . END [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE DATA CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN formula_smt ELSE formula_smt 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 254, spurious reduction of production prop -> var 
## In state 464, spurious reduction of production formula(formula_smt) -> prop 
## In state 475, spurious reduction of production formula_smt -> formula(formula_smt) 
##
touist_simple: IF VAR THEN VAR ELSE VAR WHEN 
##
## Ends in an error in state: 384.
##
## connectors(formula_simple) -> formula_simple . AND formula_simple [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_simple) -> formula_simple . OR formula_simple [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_simple) -> formula_simple . XOR formula_simple [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_simple) -> formula_simple . IMPLIES formula_simple [ XOR OR IMPLIES EQUIV END AND ]
## connectors(formula_simple) -> formula_simple . EQUIV formula_simple [ XOR OR IMPLIES EQUIV END AND ]
## if_statement(formula_simple) -> IF bool THEN formula_simple ELSE formula_simple . END [ XOR VARTUPLE VAR TUPLE TOP TERM RPAREN OR NOT LPAREN LET IMPLIES IF EXACT EQUIV EOF END ELSE DATA BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ]
##
## The known suffix of the stack is as follows:
## IF bool THEN formula_simple ELSE formula_simple 
##

Ill-formed 'if'. Expected either 'end' to finish the 'else' expression
or continue the formula that was started with
    $1
with one of the following operators:
    and, or, xor, =>, <=>
Instead, read the following statement:
    $0

touist_smt: CARD IF VAR THEN LBRACK INT RBRACK XOR 
##
## Ends in an error in state: 188.
##
## if_statement(set_int) -> IF bool THEN set_int . ELSE set_int END [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN set_int 
##
touist_smt: CARD IF VAR THEN LBRACK TERM RBRACK XOR 
##
## Ends in an error in state: 218.
##
## if_statement(set_prop) -> IF bool THEN set_prop . ELSE set_prop END [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN set_prop 
##
touist_smt: CARD IF VAR THEN VAR XOR 
##
## Ends in an error in state: 149.
##
## if_statement(set_float) -> IF bool THEN set_float . ELSE set_float END [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN OR NOT LPAREN LET INT IMPLIES IF FLOAT EXACT EQUIV EOF END ELSE COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## IF bool THEN set_float 
##

Ill-formed 'if'. Expected 'else' to finish the 'then' expression.
Instead, read the following statement:
    $0

touist_simple: TUPLE VAR XOR 
##
## Ends in an error in state: 307.
##
## prop -> TUPLE comma_list(indices) . RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK OR NOTEQUAL NOT LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## TUPLE comma_list(indices) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 254, spurious reduction of production prop -> var 
## In state 301, spurious reduction of production indices -> prop 
## In state 303, spurious reduction of production comma_list(indices) -> indices 
##

Ill-formed proposition. At this point, ')' is expected.
Instead, read the following statement:
    $0

touist_simple: TUPLE XOR 
##
## Ends in an error in state: 3.
##
## prop -> TUPLE . comma_list(indices) RPAREN [ XOR VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK OR NOTEQUAL NOT LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND ABS ]
##
## The known suffix of the stack is as follows:
## TUPLE 
##

Ill-formed proposition. At this point, a comma-separated list of indices
is expected. An index is an int, float or a proposition.
Instead, read the following statement:
    $0

touist_simple: VARTUPLE XOR 
##
## Ends in an error in state: 1.
##
## var -> VARTUPLE . comma_list(indices) RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND AFFECT ADD ABS ]
##
## The known suffix of the stack is as follows:
## VARTUPLE 
##
touist_simple: VARTUPLE VAR XOR 
##
## Ends in an error in state: 309.
##
## var -> VARTUPLE comma_list(indices) . RPAREN [ XOR WHEN VARTUPLE VAR TUPLE TOP TOINT TOFLOAT THEN TERM SUB SQRT RPAREN RBRACK RANGE OR NOTEQUAL NOT MUL MOD LT LPAREN LET LE INT IN IMPLIES IF GT GE FLOAT EXACT EQUIV EQUAL EOF END ELSE DIV DATA COMMA COLON CARD BOTTOM BIGOR BIGAND ATMOST ATLEAST AND AFFECT ADD ABS ]
##
## The known suffix of the stack is as follows:
## VARTUPLE comma_list(indices) 
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 254, spurious reduction of production prop -> var 
## In state 301, spurious reduction of production indices -> prop 
## In state 303, spurious reduction of production comma_list(indices) -> indices 
##

Ill-formed variable. At this point, a comma-separated list of indices
is expected. An index is an int, float or a proposition.
Instead, read the following statement:
    $0

touist_simple: XOR 
##
## Ends in an error in state: 0.
##
## touist_simple' -> . touist_simple [ # ]
##
## The known suffix of the stack is as follows:
## 
##
touist_smt: XOR 
##
## Ends in an error in state: 424.
##
## touist_smt' -> . touist_smt [ # ]
##
## The known suffix of the stack is as follows:
## 
##

No formula has been given.



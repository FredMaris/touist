package gui.TranslatorLatex;

terminal BEGIN,END,SETS,FORMULA,IF,THEN,ELSE;
terminal CONSTANT,SET,INT,FLOAT; 
terminal BIGAND,BIGOR,IN,NOT,OR,AND,EMPTY,SUBSET,CARD,SQRT,MOD,WHITESPACE;
terminal TRUE,FALSE,TOP,BOT,AFFECT,EQUAL,DIFFERENT,LESSER,LESSER_OR_EQUAL;
terminal GREATER,GREATER_OR_EQUAL,BOOL_AND,BOOL_OR,IMPLIQUE,EQUIV,LPAR,RPAR;
terminal ADD,MULTIPLY,SUBSTRACT,DIVIDE,LCRO,RCRO,DODOT,COMMA,TWODOT,XOR;
terminal COMMENT,DOT,UNION,INTER,DIFF,WHEN,NEWLINE;
terminal ATLEAST,EXACT,ATMOST;



terminal String VAR;
terminal String INTEGER;
terminal String DOUBLENUMBER;
terminal String IDENTIFIER;
terminal String ALPHA;
terminal String ERROR_IDENTIFIER;
terminal String LATEX;

non terminal String formule;
non terminal String set;
non terminal String expr;
non terminal String affect;
non terminal String nb;
non terminal String bool;
non terminal String set_decl;
non terminal String atom;
non terminal String term_option;
non terminal String big_body;
non terminal String var_list;
non terminal String set_list;
non terminal String program;
non terminal String var;



precedence left IMPLIQUE;
precedence left EQUIV;
precedence left AND;
precedence left OR;
precedence left XOR;

precedence left LESSER_OR_EQUAL;
precedence left LESSER;
precedence left GREATER;
precedence left GREATER_OR_EQUAL;
precedence left MOD;
precedence left SUBSTRACT,ADD;
precedence left MULTIPLY,DIVIDE;
precedence nonassoc IN;
precedence left BOOL_OR;
precedence left BOOL_AND;
precedence left TWODOT;
precedence left AFFECT;
precedence left RPAR;
precedence left LPAR;


program ::= affect:a {: RESULT = new String(a); :}
			|expr:f {: RESULT = new String(f); :}
			|affect:a program:p {: RESULT = new String(a+"\\\\"+p); :}
			|expr:f program:p {: RESULT = new String(f+"\\\\"+p); :}
			|error
;


affect ::= var:v AFFECT expr:e {: RESULT = new String(v+"="+e);:}
;

expr ::=IF expr:b THEN expr:e1 ELSE expr:e2  {: RESULT = new String("if\\;"+b+"\\;then\\;"+e1+"\\;else\\;"+e2);:}
		|LPAR expr:b RPAR {: RESULT = new String("("+b+")");:}
		|expr:s DOT LPAR expr:e RPAR {: RESULT = new String(s+".("+e+")");:}
		| bool:b {: RESULT = b;:}
		| var:v {: RESULT = v;:}
		| expr:n IN expr:s {: RESULT = new String(n+" \\in "+s);:}
		| IDENTIFIER:i IN expr:s {: RESULT = new String(i+" \\in "+s);:}
		| SUBSET LPAR expr:s1 COMMA expr:s2 RPAR {: RESULT = new String(s1+" \\subset "+s2);:}
		| expr:n1 EQUAL expr:n2 {: RESULT = new String(n1+" == "+n2);:}
		| expr:n1 DIFFERENT expr:n2 {: RESULT = new String(n1+" != "+n2);:}
		| expr:n1 LESSER expr:n2 {: RESULT = new String(n1+" < "+n2);:}
		| expr:n1 LESSER_OR_EQUAL expr:n2 {: RESULT = new String(n1+" <= "+n2);:}
		| expr:n1 GREATER expr:n2 {: RESULT = new String(n1+" > "+n2);:}
		| expr:n1 GREATER_OR_EQUAL expr:n2 {: RESULT = new String(n1+" >= "+n2);:}
		| EMPTY LPAR expr:s RPAR {: RESULT = new String("empty("+s+")");:}
		| expr:b1 BOOL_AND expr:b2 {: RESULT = new String(b1+" \\&\\& "+b2);:}
		| expr:b1 BOOL_OR expr:b2 {: RESULT = new String(b1+" || "+b2);:}
		| NOT expr:b2 {: RESULT = new String( "\\neg "+b2);:}
		| expr:b1 XOR expr:b2 {: RESULT = new String(b1+" \\oplus "+b2);:}
		| expr:b1 IMPLIQUE expr:b2 {: RESULT = new String(b1+" \\Rightarrow "+b2);:}
		| expr:b1 EQUIV expr:b2 {: RESULT = new String(b1+" \\Leftrightarrow "+b2);:}
		| TOP {: RESULT = new String("\\top");:}
		| BOT {: RESULT = new String("\\bot");:}
		| IDENTIFIER:i LPAR term_option:t RPAR {: RESULT = new String(i+"("+t+")");:}
		| IDENTIFIER:i {: RESULT = new String(i);:}
		| expr:c1 AND expr:c2 {: RESULT = new String(c1+" \\wedge "+c2);:}
		| expr:c1 OR expr:c2 {: RESULT = new String(c1+" \\vee "+c2);:}
		| expr:c1 XOR expr:c2 {: RESULT = new String(c1+" \\oplus "+c2);:}
		| BIGAND big_body:bb {: RESULT = new String("\\bigwedge"+bb);:}
		| BIGOR big_body:bb {: RESULT = new String("\\bigvee "+bb);:}
		| nb : n {: RESULT = n;:}
		| expr:n1 ADD expr:n2 {: RESULT = new String(n1+"+"+n2);:}
		| expr:n1 MULTIPLY expr:n2 {: RESULT = new String(n1+"*"+n2);:}
		| expr:n1 SUBSTRACT expr:n2 {: RESULT = new String(n1+"-"+n2);:}
		| SUBSTRACT expr:n {: RESULT = new String("-"+n);:}
		| expr:n1 DIVIDE expr:n2 {: RESULT = new String(n1+"/"+n2);:}
		| expr:n1 MOD expr:n2 {: RESULT = new String(n1+" \\% "+n2);:}
		| CARD LPAR expr:s RPAR {: RESULT = new String("card("+s+")");:}
		| INT LPAR expr:n RPAR {: RESULT = new String("int("+n+")");:}
		| FLOAT LPAR expr:n RPAR {: RESULT = new String("float("+n+")");:}
		| SQRT LPAR expr:n RPAR {: RESULT = new String("\\sqrt{"+n+"}");:}
		| LCRO RCRO {: RESULT = new String("[]");:}
		| LCRO set_decl:s RCRO {: RESULT = new String("["+s+"]");:}
		| LCRO expr:n1 DODOT expr:n2 RCRO {: RESULT = new String("["+n1+".."+n2+"]");:}
		| UNION LPAR expr:s1 COMMA expr:s2 RPAR {: RESULT = new String(s1+"\\cup"+s2);:}
		| INTER LPAR expr:s1 COMMA expr:s2 RPAR {: RESULT = new String(s1+"\\cap"+s2);:}
		| DIFF LPAR expr:s1 COMMA expr:s2 RPAR {: RESULT = new String(s1+"\\setminus"+s2);:}
		| ATLEAST LPAR expr:s1 COMMA expr:s2 COMMA expr:s3 COMMA expr:s4 RPAR  {: RESULT = new String("(\\geqslant_{"+s2+" \\in "+s3+"}^{"+s1+"}"+s4+")");:}
		| EXACT LPAR expr:s1 COMMA expr:s2 COMMA expr:s3 COMMA expr:s4 RPAR  {: RESULT = new String("(=_{"+s2+" \\in "+s3+"}^{"+s1+"}"+s4+")");:}
		| ATMOST LPAR expr:s1 COMMA expr:s2 COMMA expr:s3 COMMA expr:s4 RPAR  {: RESULT = new String("(\\leqslant_{"+s2+" \\in "+s3+"}^{"+s1+"}"+s4+")");:}
;


bool ::= TRUE {: RESULT = new String("True");:}
		| FALSE {: RESULT = new String("False");:}
;

nb ::= INTEGER:n {: RESULT = new String(n);:} 
		| DOUBLENUMBER:n {: RESULT = new String(n);:} 
;

set_decl ::= atom:a {: RESULT = a;:}
			| atom:a COMMA set_decl:s {: RESULT = new String(a+","+s);:}
;



			
term_option ::= IDENTIFIER:i {: RESULT = new String(i);:}
				| expr:e {: RESULT = e;:}
				| expr:e COMMA term_option:t {: RESULT = new String(e+","+t);:}
;

big_body ::= var_list:v IN set_list:s WHEN expr:b TWODOT expr:e END 
					{: RESULT = new String("\\limits_{\\substack{"+v+"\\in"+s+"\\\\"+ b+"}}"+e);:}
			| var_list:v IN set_list:s TWODOT expr:e END
					{: RESULT = new String("\\limits_{"+v+"\\in"+s+"}"+e);:}
;

var ::= VAR:v {: RESULT = new String("\\textbf{"+v+"}");:}
		|VAR:v LPAR term_option:t RPAR {: RESULT = new String("\\textbf{"+v+"}("+t+")"); :}
		|VAR:v LPAR IDENTIFIER:i RPAR {: RESULT = new String("\\textbf{"+v+"}("+i+")"); :}
;
atom ::= IDENTIFIER:i {: RESULT = new String(i);:}
		| bool:b {: RESULT = b;:}
		| nb:n {: RESULT = n;:}
;

var_list ::= var:v {: RESULT = new String(v);:}
			| var:v COMMA var_list:vl {: RESULT = new String(v+","+vl);:}
;

set_list ::= expr:s {: RESULT = new String(s);:}
			| expr:s COMMA set_list:sl {:RESULT = new String(s+","+sl);:}
;
